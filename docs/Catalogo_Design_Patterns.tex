\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{tikz}
\usepackage{longtable}
\usepackage{booktabs}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric, shapes.multipart}

\geometry{margin=2.5cm}

% Configurazione listings per Java
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.97,0.97,0.97}
\definecolor{keywordcolor}{rgb}{0.0,0.0,0.7}

\lstdefinestyle{javastyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen}\itshape,
    keywordstyle=\color{keywordcolor}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    language=Java,
    morekeywords={var, record, sealed, permits, yield}
}

\lstset{style=javastyle}

\pagestyle{fancy}
\fancyhf{}
\rhead{Design Patterns}
\lhead{Habibi Shawarma}
\rfoot{Pagina \thepage}

\title{\textbf{Catalogo Completo dei Design Pattern} \\ 
\large Implementazione nel Progetto Habibi Shawarma \\
\vspace{0.5cm}
\normalsize Definizioni Formali, Applicabilità e Mappature}
\author{Daniel Di Meo}
\date{15 Gennaio 2026}

\begin{document}

\maketitle
\tableofcontents
\newpage

% ==============================================================================
\section{Introduzione}
% ==============================================================================

Questo documento fornisce un'analisi tecnica completa di tutti i design pattern implementati nel progetto Habibi Shawarma, con particolare focus sullo Use Case \textbf{Crea Ordine}.

Per ogni pattern viene presentata:
\begin{itemize}
    \item \textbf{Definizione Formale}: dal libro "Design Patterns" (GoF, 1994)
    \item \textbf{Intento}: lo scopo del pattern
    \item \textbf{Applicabilità}: quando usare il pattern
    \item \textbf{Struttura UML}: diagramma delle classi
    \item \textbf{Mappatura Progetto}: corrispondenza tra ruoli GoF e classi del progetto
    \item \textbf{Codice}: estratti implementativi
\end{itemize}

% ==============================================================================
\section{Pattern Creazionali}
% ==============================================================================

% ------------------------------------------------------------------------------
\subsection{Singleton}
% ------------------------------------------------------------------------------

\subsubsection{Definizione Formale (GoF)}

\begin{quote}
\textit{"Ensure a class only has one instance, and provide a global point of access to it."}
\end{quote}

\textbf{Traduzione}: Garantisce che una classe abbia una sola istanza e fornisce un punto di accesso globale ad essa.

\subsubsection{Intento}

\begin{itemize}
    \item Controllare l'accesso all'unica istanza
    \item Permettere un numero variabile di istanze (generalizzazione: 1 sola)
    \item Sostituire le variabili globali con un meccanismo OOP
\end{itemize}

\subsubsection{Applicabilità}

Usare il Singleton quando:
\begin{enumerate}
    \item Deve esistere esattamente una istanza di una classe
    \item L'istanza unica deve essere accessibile da un punto ben noto
    \item L'istanza unica deve essere estendibile tramite subclassing
\end{enumerate}

\subsubsection{Struttura}

\begin{center}
\begin{tikzpicture}[
    class/.style={rectangle split, rectangle split parts=3, draw, minimum width=4cm, align=center}
]
    \node[class] (singleton) {
        \textbf{Singleton}
        \nodepart{second}
        \texttt{-instance: Singleton}
        \nodepart{third}
        \texttt{+getInstance(): Singleton} \\
        \texttt{-Singleton()}
    };
\end{tikzpicture}
\end{center}

\subsubsection{Mappatura nel Progetto}

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Ruolo GoF} & \textbf{Classe Progetto} & \textbf{Package} \\
\hline
Singleton & \texttt{OrdineEventPublisher} & \texttt{events} \\
\hline
Singleton & \texttt{AdminNotificationService} & \texttt{services} \\
\hline
Singleton & \texttt{SessionManager} & \texttt{session\_manager} \\
\hline
Singleton & \texttt{OrdineLazyFactory} & \texttt{model.ordine} \\
\hline
Singleton & \texttt{FoodLazyFactory} & \texttt{model.food} \\
\hline
Singleton & \texttt{DAOFactoryAbstract} & \texttt{dao\_manager} \\
\hline
\end{tabular}
\end{center}

\subsubsection{Implementazione}

\begin{lstlisting}[caption={Singleton in OrdineEventPublisher}]
public class OrdineEventPublisher {
    // Campo statico per l'unica istanza
    private static OrdineEventPublisher instance;
    
    // Costruttore privato: nessuno puo' fare "new"
    private OrdineEventPublisher() {
        this.listeners = new ArrayList<>();
        this.pendingEvents = new ConcurrentLinkedQueue<>();
    }
    
    // Punto di accesso globale, thread-safe
    public static synchronized OrdineEventPublisher getInstance() {
        if (instance == null) {
            instance = new OrdineEventPublisher();
        }
        return instance;
    }
}
\end{lstlisting}

% ------------------------------------------------------------------------------
\subsection{Abstract Factory}
% ------------------------------------------------------------------------------

\subsubsection{Definizione Formale (GoF)}

\begin{quote}
\textit{"Provide an interface for creating families of related or dependent objects without specifying their concrete classes."}
\end{quote}

\textbf{Traduzione}: Fornisce un'interfaccia per creare famiglie di oggetti correlati senza specificare le loro classi concrete.

\subsubsection{Intento}

\begin{itemize}
    \item Astrarre il processo di creazione di oggetti
    \item Garantire che prodotti correlati vengano usati insieme
    \item Isolare le classi client dalle classi concrete dei prodotti
\end{itemize}

\subsubsection{Applicabilità}

Usare Abstract Factory quando:
\begin{enumerate}
    \item Un sistema deve essere indipendente da come i suoi prodotti sono creati
    \item Un sistema deve essere configurato con una di più famiglie di prodotti
    \item Si vuole fornire una libreria di prodotti mostrando solo le interfacce
\end{enumerate}

\subsubsection{Struttura}

\begin{center}
\begin{tikzpicture}[
    class/.style={rectangle, draw, minimum width=3cm, minimum height=1cm, align=center},
    arrow/.style={-{Stealth[length=2mm]}, thick}
]
    \node[class] (af) at (0,0) {\textbf{AbstractFactory}};
    \node[class] (cf1) at (-2.5,-2) {ConcreteFactory1};
    \node[class] (cf2) at (2.5,-2) {ConcreteFactory2};
    \node[class] (ap) at (6,0) {\textbf{AbstractProduct}};
    \node[class] (cp1) at (6,-2) {ConcreteProduct};
    
    \draw[arrow] (cf1) -- (af);
    \draw[arrow] (cf2) -- (af);
    \draw[arrow, dashed] (af) -- (ap);
    \draw[arrow] (cp1) -- (ap);
\end{tikzpicture}
\end{center}

\subsubsection{Mappatura nel Progetto (DAO Layer)}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Ruolo GoF} & \textbf{Classe Progetto} \\
\hline
AbstractFactory & \texttt{DAOFactoryAbstract} \\
\hline
ConcreteFactory1 & \texttt{DAOFactoryDB} (database H2) \\
\hline
ConcreteFactory2 & \texttt{DAOFactoryFS} (file system CSV) \\
\hline
ConcreteFactory3 & \texttt{DAOFactoryDemo} (in-memory) \\
\hline
AbstractProduct & \texttt{OrdineDAOInterface} \\
\hline
ConcreteProduct1 & \texttt{OrdineDAODB} \\
\hline
ConcreteProduct2 & \texttt{OrdineDAOFS} \\
\hline
ConcreteProduct3 & \texttt{OrdineDAODemo} \\
\hline
\end{tabular}
\end{center}

\subsubsection{Implementazione}

\begin{lstlisting}[caption={Abstract Factory nel DAO Layer}]
public abstract class DAOFactoryAbstract {
    // Factory Method per ogni tipo di DAO
    public abstract OrdineDAOInterface getOrdineDAO();
    public abstract VoucherDAOInterface getVoucherDAO();
    public abstract UserDAOInterface getUserDAO();
    
    // Singleton + Factory Method per ottenere il factory corretto
    public static DAOFactoryAbstract getInstance() {
        String mode = ConfigReader.getProperty("persistence.mode");
        return switch (mode) {
            case "DB" -> DAOFactoryDB.getInstance();
            case "FS" -> DAOFactoryFS.getInstance();
            default -> DAOFactoryDemo.getInstance();
        };
    }
}
\end{lstlisting}

% ------------------------------------------------------------------------------
\subsection{Factory Method (Simple Factory)}
% ------------------------------------------------------------------------------

\subsubsection{Definizione Formale (GoF)}

\begin{quote}
\textit{"Define an interface for creating an object, but let subclasses decide which class to instantiate."}
\end{quote}

\subsubsection{Mappatura nel Progetto}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Ruolo GoF} & \textbf{Classe Progetto} \\
\hline
Creator & \texttt{FoodFactory} \\
\hline
Product & \texttt{Food} (interfaccia) \\
\hline
ConcreteProduct1 & \texttt{PaninoDonerKebab} \\
\hline
ConcreteProduct2 & \texttt{PiadinaFalafel} \\
\hline
ConcreteProduct3 & \texttt{RollDurum} \\
\hline
\end{tabular}
\end{center}

\subsubsection{Implementazione}

\begin{lstlisting}[caption={Factory Method in FoodFactory}]
public class FoodFactory {
    public static Food creaProdottoBase(String classe) {
        return switch (classe) {
            case "PaninoDonerKebab" -> new PaninoDonerKebab();
            case "PiadinaFalafel" -> new PiadinaFalafel();
            case "RollDurum" -> new RollDurum();
            default -> null;
        };
    }
    
    public static Food creaAddOn(String classe) {
        return switch (classe) {
            case "CipolleCroccanti" -> new CipolleCroccanti(null);
            case "SalsaPiccante" -> new SalsaPiccante(null);
            default -> null;
        };
    }
}
\end{lstlisting}

% ==============================================================================
\section{Pattern Strutturali}
% ==============================================================================

% ------------------------------------------------------------------------------
\subsection{Decorator}
% ------------------------------------------------------------------------------

\subsubsection{Definizione Formale (GoF)}

\begin{quote}
\textit{"Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality."}
\end{quote}

\textbf{Traduzione}: Aggiunge responsabilità a un oggetto dinamicamente. I decoratori forniscono un'alternativa flessibile all'ereditarietà per estendere le funzionalità.

\subsubsection{Intento}

\begin{itemize}
    \item Aggiungere comportamento a singoli oggetti, non alla classe
    \item Permettere combinazioni arbitrarie di comportamenti
    \item Evitare l'esplosione di sottoclassi
\end{itemize}

\subsubsection{Applicabilità}

Usare il Decorator quando:
\begin{enumerate}
    \item Si vogliono aggiungere responsabilità a singoli oggetti dinamicamente
    \item L'estensione tramite subclassing è impraticabile (troppe combinazioni)
    \item Si vuole che le responsabilità possano essere rimosse
\end{enumerate}

\subsubsection{Struttura}

\begin{center}
\begin{tikzpicture}[
    class/.style={rectangle split, rectangle split parts=2, draw, minimum width=3cm, align=center},
    arrow/.style={-{Stealth[length=2mm]}, thick}
]
    \node[class] (comp) at (0,0) {\textbf{Component} \nodepart{second} \texttt{+operation()}};
    \node[class] (concrete) at (-3,-2.5) {ConcreteComponent \nodepart{second} \texttt{+operation()}};
    \node[class] (deco) at (3,-2.5) {\textbf{Decorator} \nodepart{second} \texttt{-component} \\ \texttt{+operation()}};
    \node[class] (cdeco) at (3,-5) {ConcreteDecorator \nodepart{second} \texttt{+operation()} \\ \texttt{+addedBehavior()}};
    
    \draw[arrow] (concrete) -- (comp);
    \draw[arrow] (deco) -- (comp);
    \draw[arrow] (cdeco) -- (deco);
    \draw[arrow, dashed] (deco) -- node[above, sloped] {wraps} (comp);
\end{tikzpicture}
\end{center}

\subsubsection{Mappatura nel Progetto (Add-On per Food)}

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Ruolo GoF} & \textbf{Classe Progetto} & \textbf{Descrizione} \\
\hline
Component & \texttt{Food} & Interfaccia prodotto \\
\hline
ConcreteComponent & \texttt{PaninoDonerKebab} & Prodotto base \\
\hline
ConcreteComponent & \texttt{PiadinaFalafel} & Prodotto base \\
\hline
Decorator & \texttt{DecoratorAddON} & Decoratore astratto \\
\hline
ConcreteDecorator & \texttt{CipolleCroccanti} & Add-on concreto \\
\hline
ConcreteDecorator & \texttt{SalsaPiccante} & Add-on concreto \\
\hline
ConcreteDecorator & \texttt{FormaggioFuso} & Add-on concreto \\
\hline
\end{tabular}
\end{center}

\subsubsection{Implementazione}

\begin{lstlisting}[caption={Decorator per gli Add-On}]
// Component
public interface Food {
    String getDescrizione();
    double getCosto();
    int getDurata();
}

// ConcreteComponent
public class PaninoDonerKebab implements Food {
    public String getDescrizione() { return "Panino Doner Kebab"; }
    public double getCosto() { return 6.00; }
    public int getDurata() { return 5; }
}

// Decorator
public abstract class DecoratorAddON implements Food {
    protected Food foodDecorato;  // Aggregazione
    
    protected DecoratorAddON(Food food) {
        this.foodDecorato = food;
    }
    
    public String getDescrizione() {
        return foodDecorato.getDescrizione();
    }
    
    public double getCosto() {
        return foodDecorato.getCosto();
    }
}

// ConcreteDecorator
public class CipolleCroccanti extends DecoratorAddON {
    public CipolleCroccanti(Food food) {
        super(food);
    }
    
    @Override
    public String getDescrizione() {
        return super.getDescrizione() + " + Cipolle Croccanti";
    }
    
    @Override
    public double getCosto() {
        return super.getCosto() + 1.50;
    }
}
\end{lstlisting}

\subsubsection{Esempio d'Uso}

\begin{lstlisting}[caption={Composizione dinamica con Decorator}]
// Creazione base
Food prodotto = new PaninoDonerKebab();  // 6.00 euro

// Decorazione dinamica
prodotto = new CipolleCroccanti(prodotto);  // +1.50
prodotto = new SalsaPiccante(prodotto);     // +0.50
prodotto = new FormaggioFuso(prodotto);     // +1.00

// Risultato
prodotto.getDescrizione(); 
// "Panino Doner Kebab + Cipolle Croccanti + Salsa Piccante + Formaggio Fuso"

prodotto.getCosto();  // 9.00 euro
\end{lstlisting}

% ------------------------------------------------------------------------------
\subsection{Facade}
% ------------------------------------------------------------------------------

\subsubsection{Definizione Formale (GoF)}

\begin{quote}
\textit{"Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use."}
\end{quote}

\textbf{Traduzione}: Fornisce un'interfaccia unificata a un insieme di interfacce di un sottosistema. Facade definisce un'interfaccia di livello superiore che rende il sottosistema più facile da usare.

\subsubsection{Intento}

\begin{itemize}
    \item Semplificare l'uso di sottosistemi complessi
    \item Disaccoppiare il client dal sottosistema
    \item Fornire un punto di ingresso ben definito
\end{itemize}

\subsubsection{Applicabilità}

Usare il Facade quando:
\begin{enumerate}
    \item Si vuole fornire una semplice interfaccia a un sottosistema complesso
    \item Ci sono molte dipendenze tra client e classi del sottosistema
    \item Si vuole stratificare i sottosistemi (facade per ogni layer)
\end{enumerate}

\subsubsection{Mappatura nel Progetto}

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Ruolo GoF} & \textbf{Classe Progetto} & \textbf{Use Case} \\
\hline
Facade & \texttt{CreaOrdineFacade} & Crea Ordine \\
\hline
Facade & \texttt{UsaVoucherFacade} & Usa Voucher (extend) \\
\hline
Facade & \texttt{CreaVoucherFacade} & Crea Voucher \\
\hline
Facade & \texttt{VisualizzaOrdiniFacade} & Visualizza Ordini \\
\hline
Facade & \texttt{StoricoOrdiniFacade} & Storico Ordini \\
\hline
Subsystem Classes & \texttt{FoodFactory, FoodLazyFactory} & Gestione Food \\
\hline
Subsystem Classes & \texttt{OrdineLazyFactory} & Gestione Ordini \\
\hline
Subsystem Classes & \texttt{VoucherLazyFactory} & Gestione Voucher \\
\hline
\end{tabular}
\end{center}

\subsubsection{Implementazione}

\begin{lstlisting}[caption={Facade per lo Use Case Crea Ordine}]
public class CreaOrdineFacade {
    
    // Il Facade nasconde la complessita' del sottosistema
    public List<FoodBean> getProdottiBaseDisponibili() {
        // Interagisce con FoodLazyFactory internamente
        return FoodLazyFactory.getInstance()
            .getProdottiBase()
            .stream()
            .map(this::toFoodBean)
            .collect(Collectors.toList());
    }
    
    public RiepilogoOrdineBean calcolaRiepilogo(OrdineBean ordine) {
        // Calcoli complessi nascosti dietro un metodo semplice
        // ...
    }
}
\end{lstlisting}

% ==============================================================================
\section{Pattern Comportamentali}
% ==============================================================================

% ------------------------------------------------------------------------------
\subsection{Observer}
% ------------------------------------------------------------------------------

\subsubsection{Definizione Formale (GoF)}

\begin{quote}
\textit{"Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically."}
\end{quote}

\textbf{Traduzione}: Definisce una dipendenza uno-a-molti tra oggetti in modo che quando un oggetto cambia stato, tutti i suoi dipendenti vengono notificati e aggiornati automaticamente.

\subsubsection{Intento}

\begin{itemize}
    \item Mantenere la consistenza tra oggetti correlati
    \item Accoppiamento lasco: il subject non conosce i dettagli degli observer
    \item Notifica broadcast: tutti gli observer registrati vengono notificati
\end{itemize}

\subsubsection{Applicabilità}

Usare l'Observer quando:
\begin{enumerate}
    \item Un'astrazione ha due aspetti: uno dipende dall'altro
    \item Un cambio in un oggetto richiede cambi in altri, senza sapere quanti
    \item Un oggetto deve notificare altri senza fare assunzioni su chi siano
\end{enumerate}

\subsubsection{Struttura}

\begin{center}
\begin{tikzpicture}[
    class/.style={rectangle split, rectangle split parts=2, draw, minimum width=3.5cm, align=center},
    arrow/.style={-{Stealth[length=2mm]}, thick}
]
    \node[class] (subject) at (0,0) {\textbf{Subject} \nodepart{second} \texttt{+attach()} \\ \texttt{+detach()} \\ \texttt{+notify()}};
    \node[class] (observer) at (6,0) {\textbf{Observer} \nodepart{second} \texttt{+update()}};
    \node[class] (csub) at (0,-3) {ConcreteSubject \nodepart{second} \texttt{-state} \\ \texttt{+getState()}};
    \node[class] (cobs) at (6,-3) {ConcreteObserver \nodepart{second} \texttt{-subject} \\ \texttt{+update()}};
    
    \draw[arrow] (csub) -- (subject);
    \draw[arrow] (cobs) -- (observer);
    \draw[arrow, dashed] (subject) -- node[above] {observers} (observer);
    \draw[arrow, dashed] (cobs) -- node[above] {subject} (csub);
\end{tikzpicture}
\end{center}

\subsubsection{Mappatura nel Progetto}

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Ruolo GoF} & \textbf{Classe Progetto} & \textbf{Descrizione} \\
\hline
Subject & \texttt{OrdineEventPublisher} & Publisher Singleton \\
\hline
Observer & \texttt{OrdineEventListener} & Interfaccia funzionale \\
\hline
ConcreteObserver & \texttt{AdminNotificationService} & Servizio notifiche \\
\hline
Event/State & \texttt{OrdineEvent} & Dati dell'evento \\
\hline
Client (attach) & \texttt{AdminHomepageGUIController} & Registra l'observer \\
\hline
Client (notify) & \texttt{CreaOrdineController} & Pubblica eventi \\
\hline
\end{tabular}
\end{center}

\subsubsection{Implementazione Completa}

\begin{lstlisting}[caption={Observer Pattern - Subject}]
// Subject (Publisher)
public class OrdineEventPublisher {
    private static OrdineEventPublisher instance;
    private final List<OrdineEventListener> listeners;
    private final Queue<OrdineEvent> pendingEvents;
    
    public void addListener(OrdineEventListener listener) {
        synchronized (listeners) {
            listeners.add(listener);
            // Consegna eventi pendenti al nuovo listener
            for (OrdineEvent event : pendingEvents) {
                listener.onOrdineConfermato(event);
            }
        }
    }
    
    public void notifyOrdineConfermato(OrdineEvent event) {
        List<OrdineEventListener> copy;
        synchronized (listeners) {
            copy = new ArrayList<>(listeners);
        }
        
        if (copy.isEmpty()) {
            pendingEvents.add(event);  // Accoda per consegna futura
            return;
        }
        
        for (OrdineEventListener listener : copy) {
            listener.onOrdineConfermato(event);
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={Observer Pattern - Observer Interface}]
// Observer Interface
@FunctionalInterface
public interface OrdineEventListener {
    void onOrdineConfermato(OrdineEvent event);
}
\end{lstlisting}

\begin{lstlisting}[caption={Observer Pattern - Concrete Observer}]
// Concrete Observer
public class AdminNotificationService implements OrdineEventListener {
    private final Queue<OrdineEvent> pendingNotifications;
    private Runnable onNewNotification;  // Callback per UI
    
    @Override
    public void onOrdineConfermato(OrdineEvent event) {
        pendingNotifications.add(event);
        if (onNewNotification != null) {
            Platform.runLater(onNewNotification);
        }
    }
    
    public void register() {
        OrdineEventPublisher.getInstance().addListener(this);
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={Observer Pattern - Client Usage}]
// In CreaOrdineController (pubblica eventi)
public boolean confermaOrdine() throws DAOException {
    OrdineLazyFactory.getInstance().salvaOrdine(ordineCorrente);
    
    // NOTIFICA ATTIVA (Pattern Observer)
    OrdineEvent event = new OrdineEvent(
        ordineCorrente.getNumeroOrdine(),
        ordineCorrente.getClienteId(),
        ordineCorrente.getTotale());
    OrdineEventPublisher.getInstance().notifyOrdineConfermato(event);
    
    return true;
}

// In AdminHomepageGUIController (riceve notifiche)
public void initialize(URL location, ResourceBundle resources) {
    AdminNotificationService service = AdminNotificationService.getInstance();
    service.register();
    service.setOnNewNotification(this::onNuovaNotificaRicevuta);
}
\end{lstlisting}

% ==============================================================================
\section{Pattern Architetturali}
% ==============================================================================

% ------------------------------------------------------------------------------
\subsection{BCE (Boundary-Control-Entity)}
% ------------------------------------------------------------------------------

\subsubsection{Definizione}

BCE è un pattern architetturale derivato da MVC, utilizzato in Unified Process:
\begin{itemize}
    \item \textbf{Boundary}: Interfaccia con attori esterni (GUI, CLI, API)
    \item \textbf{Control}: Logica applicativa e coordinamento use case
    \item \textbf{Entity}: Oggetti di dominio persistenti
\end{itemize}

\subsubsection{Mappatura nel Progetto (Use Case Crea Ordine)}

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Layer BCE} & \textbf{Classe Progetto} & \textbf{Responsabilità} \\
\hline
\multirow{2}{*}{Boundary} & \texttt{CreaOrdineGUIController} & Interfaccia JavaFX \\
 & \texttt{CreaOrdineCLIController} & Interfaccia CLI \\
\hline
\multirow{2}{*}{Control} & \texttt{CreaOrdineController} & Logica applicativa \\
 & \texttt{CreaOrdineFacade} & Semplificazione sottosistema \\
\hline
\multirow{3}{*}{Entity} & \texttt{Ordine} & Entità Ordine \\
 & \texttt{Food} & Entità Prodotto \\
 & \texttt{Voucher} & Entità Voucher \\
\hline
\end{tabular}
\end{center}

\subsubsection{Flusso dei Dati}

\begin{center}
\begin{tikzpicture}[
    layer/.style={rectangle, draw, minimum width=4cm, minimum height=1.2cm, align=center},
    arrow/.style={-{Stealth[length=3mm]}, thick}
]
    \node[layer, fill=blue!20] (boundary) at (0,0) {\textbf{Boundary} \\ GUIController};
    \node[layer, fill=green!20] (bean) at (5,0) {\textbf{Bean} \\ FoodBean, OrdineBean};
    \node[layer, fill=orange!20] (control) at (10,0) {\textbf{Control} \\ Controller};
    \node[layer, fill=red!20] (entity) at (10,-2.5) {\textbf{Entity} \\ Ordine, Food};
    
    \draw[arrow] (boundary) -- node[above] {crea} (bean);
    \draw[arrow] (bean) -- node[above] {passa} (control);
    \draw[arrow] (control) -- node[right] {usa} (entity);
\end{tikzpicture}
\end{center}

% ==============================================================================
\section{Principi GRASP Applicati}
% ==============================================================================

\begin{center}
\begin{longtable}{|p{3cm}|p{4cm}|p{6cm}|}
\hline
\textbf{Principio} & \textbf{Dove Applicato} & \textbf{Come} \\
\hline
\endfirsthead
\hline
\textbf{Principio} & \textbf{Dove Applicato} & \textbf{Come} \\
\hline
\endhead
\hline
\endfoot
Information Expert & \texttt{Ordine.calcolaTotale()} & L'ordine ha i dati per calcolare il totale \\
\hline
Creator & \texttt{FoodFactory} & Crea oggetti Food \\
\hline
Controller & \texttt{CreaOrdineController} & Coordina lo use case \\
\hline
Low Coupling & Observer Pattern & Publisher non conosce AdminNotificationService \\
\hline
High Cohesion & Un Facade per Use Case & Ogni classe ha una responsabilità chiara \\
\hline
Polymorphism & \texttt{DAOFactoryAbstract} & Cambio DB/FS/Demo senza modificare codice \\
\hline
Pure Fabrication & \texttt{OrdineEventPublisher} & Classe di servizio non del dominio \\
\hline
Indirection & \texttt{AdminNotificationService} & Intermediario tra eventi e UI \\
\hline
Protected Variations & \texttt{OrdineEventListener} & Interfaccia protegge da cambiamenti \\
\hline
\end{longtable}
\end{center}

% ==============================================================================
\section{Riepilogo Pattern per Use Case}
% ==============================================================================

\subsection{Use Case: Crea Ordine}

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Pattern} & \textbf{Classi Coinvolte} & \textbf{Scopo} \\
\hline
Facade & \texttt{CreaOrdineFacade} & Semplifica sottosistema ordini \\
\hline
Factory Method & \texttt{FoodFactory} & Crea prodotti dinamicamente \\
\hline
Decorator & \texttt{DecoratorAddON} & Add-on composibili \\
\hline
Observer & \texttt{OrdineEventPublisher} & Notifica admin \\
\hline
Singleton & \texttt{OrdineLazyFactory} & Unico punto accesso ordini \\
\hline
Abstract Factory & \texttt{DAOFactoryAbstract} & Persistenza pluggable \\
\hline
\end{tabular}
\end{center}

\subsection{Use Case: Usa Voucher (extend di Crea Ordine)}

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Pattern} & \textbf{Classi Coinvolte} & \textbf{Scopo} \\
\hline
Facade & \texttt{UsaVoucherFacade} & Gestione voucher isolata \\
\hline
Strategy & \texttt{VoucherPercentuale/Fisso} & Strategie di sconto \\
\hline
Singleton & \texttt{VoucherLazyFactory} & Accesso voucher \\
\hline
\end{tabular}
\end{center}

% ==============================================================================
\section{Conclusioni}
% ==============================================================================

Il progetto Habibi Shawarma implementa i seguenti pattern:

\begin{itemize}
    \item \textbf{Creazionali}: Singleton (6 classi), Abstract Factory (DAO), Factory Method (Food)
    \item \textbf{Strutturali}: Decorator (Add-On), Facade (5 use case)
    \item \textbf{Comportamentali}: Observer (notifiche admin), Strategy (voucher)
    \item \textbf{Architetturali}: BCE (separazione layer)
\end{itemize}

Ogni pattern è stato scelto per rispondere a specifiche esigenze architetturali, garantendo:
\begin{itemize}
    \item \textbf{Estensibilità}: nuovi prodotti, nuovi DAO, nuovi observer
    \item \textbf{Manutenibilità}: classi con responsabilità singole
    \item \textbf{Testabilità}: dipendenze iniettabili e sostituibili
    \item \textbf{Conformità ai Requisiti}: notifica attiva verso A2 (Observer)
\end{itemize}

\end{document}
