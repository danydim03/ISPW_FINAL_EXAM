% ============================================================================
%               PATTERN DECORATOR NELL'APPLICAZIONE HABIBI
%                     Analisi Tecnica e Implementazione
% ============================================================================
\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{tcolorbox}
\usepackage{fancyhdr}
\usepackage{booktabs}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,calc}

\geometry{margin=2.5cm}

% Colori
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{habibiGold}{RGB}{154,130,98}

\lstdefinestyle{java}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=single,
    language=Java
}
\lstset{style=java}

\title{
    \vspace{-1cm}
    {\Huge \textbf{Pattern Decorator}}\\[0.5cm]
    {\Large Analisi Tecnica dell'Implementazione}\\[0.3cm]
    {\large Applicazione Habibi - Sistema Gestione Kebab}
}
\author{Documentazione Tecnica}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

% ============================================================================
\section{Introduzione al Pattern Decorator}
% ============================================================================

\subsection{Definizione GoF}

Il \textbf{Decorator} è un pattern strutturale che permette di aggiungere dinamicamente nuove responsabilità a un oggetto senza modificare la sua classe.

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black,title=Intent (GoF)]
``Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.''
\end{tcolorbox}

\subsection{Problema Risolto}

Nel contesto dell'applicazione Habibi, il problema è:

\begin{quote}
\textit{Come possiamo aggiungere add-on (cipolla, salsa yogurt, patatine) a un prodotto base (panino kebab) senza creare una classe per ogni combinazione possibile?}
\end{quote}

\textbf{Senza Decorator} (esplosione combinatoria):
\begin{itemize}
    \item PaninoDonerKebab
    \item PaninoDonerKebabConCipolla
    \item PaninoDonerKebabConSalsa
    \item PaninoDonerKebabConCipollaESalsa
    \item ... (infinite combinazioni!)
\end{itemize}

\textbf{Con Decorator}: Solo 4 classi concrete (Cipolla, SalsaYogurt, Patatine, MixVerdure) che possono essere combinate a piacere.

% ============================================================================
\section{Struttura del Pattern}
% ============================================================================

\subsection{Diagramma UML Generico}

\begin{center}
\begin{tikzpicture}[
    node distance=1.2cm and 2.5cm,
    every node/.style={font=\small},
    interface/.style={rectangle, draw, fill=yellow!20, text width=3.5cm, text centered, minimum height=1cm},
    abstract/.style={rectangle, draw, fill=blue!20, text width=3.5cm, text centered, minimum height=1cm, font=\itshape},
    concrete/.style={rectangle, draw, fill=green!20, text width=3cm, text centered, minimum height=0.8cm},
    arrow/.style={->, thick},
    inherit/.style={->, thick, >=open triangle 60}
]
    % Component
    \node[interface] (component) {\textbf{«interface»}\\Component\\+operation()};
    
    % ConcreteComponent
    \node[concrete, below left=2cm and 1cm of component] (concrete) {ConcreteComponent\\+operation()};
    
    % Decorator
    \node[abstract, below right=2cm and 1cm of component] (decorator) {\textit{Decorator}\\-component\\+operation()};
    
    % Concrete Decorators
    \node[concrete, below left=1.5cm and 0cm of decorator] (decA) {ConcreteDecoratorA};
    \node[concrete, below right=1.5cm and 0cm of decorator] (decB) {ConcreteDecoratorB};
    
    % Arrows
    \draw[inherit] (concrete) -- (component);
    \draw[inherit] (decorator) -- (component);
    \draw[inherit] (decA) -- (decorator);
    \draw[inherit] (decB) -- (decorator);
    
    % Composition arrow
    \draw[arrow, dashed] (decorator) -- node[above, sloped] {wraps} (component);
\end{tikzpicture}
\end{center}

\subsection{Partecipanti}

\begin{table}[h]
\centering
\begin{tabular}{|l|p{9cm}|}
\hline
\textbf{Ruolo} & \textbf{Descrizione} \\
\hline
\textbf{Component} & Interfaccia/classe astratta che definisce le operazioni \\
\textbf{ConcreteComponent} & Oggetto base a cui aggiungere responsabilità \\
\textbf{Decorator} & Classe astratta che wrappa il Component \\
\textbf{ConcreteDecorator} & Aggiunge comportamento specifico \\
\hline
\end{tabular}
\end{table}

% ============================================================================
\section{Implementazione in Habibi}
% ============================================================================

\subsection{Mappatura dei Ruoli}

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Ruolo GoF} & \textbf{Classe Habibi} & \textbf{Package} \\
\hline
Component & \texttt{Food} (abstract) & \texttt{model.food} \\
ConcreteComponent & \texttt{PaninoDonerKebab}, \texttt{PiadinaDonerKebab}, \texttt{KebabAlPiatto} & \texttt{model.food} \\
Decorator & \texttt{DecoratorAddON} (abstract) & \texttt{model.food.decorator} \\
ConcreteDecorator & \texttt{Cipolla}, \texttt{SalsaYogurt}, \texttt{Patatine}, \texttt{MixVerdureGrigliate} & \texttt{model.food.decorator} \\
\hline
\end{tabular}
\caption{Mappatura Pattern $\rightarrow$ Implementazione}
\end{table}

\subsection{Diagramma UML Habibi}

\begin{center}
\begin{tikzpicture}[
    node distance=1cm and 1.5cm,
    every node/.style={font=\footnotesize},
    abstract/.style={rectangle, draw, fill=blue!15, text width=4cm, minimum height=1.2cm, align=center},
    concrete/.style={rectangle, draw, fill=green!15, text width=3.2cm, minimum height=0.9cm, align=center},
    inherit/.style={->, thick, >=open triangle 60}
]
    % Food
    \node[abstract] (food) at (0,0) {\textbf{\textit{«abstract» Food}}\\id, descrizione, tipo\\getCosto(), getDurata()};
    
    % Concrete Components
    \node[concrete, below left=2.5cm and 2cm of food] (panino) {PaninoDonerKebab\\COSTO: €5.50\\DURATA: 5min};
    \node[concrete, left=0.3cm of panino] (piadina) {PiadinaDonerKebab\\COSTO: €6.00\\DURATA: 6min};
    \node[concrete, right=0.3cm of panino] (piatto) {KebabAlPiatto\\COSTO: €8.00\\DURATA: 8min};
    
    % Decorator
    \node[abstract, below right=2.5cm and 2cm of food] (decorator) {\textbf{\textit{«abstract» DecoratorAddON}}\\foodDecorato: Food\\getCostoPlus(), getDurataPlus()};
    
    % Concrete Decorators
    \node[concrete, below=1.8cm of decorator, xshift=-2.5cm] (cipolla) {Cipolla\\+€0.50, +1min};
    \node[concrete, right=0.2cm of cipolla] (salsa) {SalsaYogurt\\+€0.75, +1min};
    \node[concrete, right=0.2cm of salsa] (patatine) {Patatine\\+€1.50, +3min};
    \node[concrete, right=0.2cm of patatine] (verdure) {MixVerdure\\+€1.00, +2min};
    
    % Inheritance arrows
    \draw[inherit] (panino) -- (food);
    \draw[inherit] (piadina) -- (food);
    \draw[inherit] (piatto) -- (food);
    \draw[inherit] (decorator) -- (food);
    \draw[inherit] (cipolla) -- (decorator);
    \draw[inherit] (salsa) -- (decorator);
    \draw[inherit] (patatine) -- (decorator);
    \draw[inherit] (verdure) -- (decorator);
    
    % Composition
    \draw[->, dashed, thick] (decorator.west) -- +(-1,0) |- node[near start, above] {wraps} (food.south);
\end{tikzpicture}
\end{center}

% ============================================================================
\section{Analisi del Codice}
% ============================================================================

\subsection{Component: Food (Classe Astratta)}

\begin{lstlisting}[caption=Food.java - Component]
public abstract class Food {

    protected Long id;
    protected String descrizione = "Sconosciuto";
    protected String tipo; // "BASE" o "ADDON"

    // Metodi astratti che ogni Food deve implementare
    public abstract double getCosto();
    public abstract int getDurata();

    // Getters/Setters...
    public String getDescrizione() {
        return descrizione;
    }
}
\end{lstlisting}

\textbf{Analisi:}
\begin{itemize}
    \item Definisce l'\textbf{interfaccia comune} per tutti i prodotti
    \item I metodi \texttt{getCosto()} e \texttt{getDurata()} sono \textbf{astratti}
    \item Ogni sottoclasse (base o decorator) deve implementarli
\end{itemize}

\subsection{ConcreteComponent: PaninoDonerKebab}

\begin{lstlisting}[caption=PaninoDonerKebab.java - ConcreteComponent]
public class PaninoDonerKebab extends Food {

    private static final double COSTO_BASE = 5.50;
    private static final int DURATA_BASE = 5;

    public PaninoDonerKebab() {
        super();
        this.descrizione = "Panino Doner Kebab";
        this.tipo = "BASE";
    }

    @Override
    public double getCosto() {
        return COSTO_BASE;  // Restituisce solo il costo base
    }

    @Override
    public int getDurata() {
        return DURATA_BASE;  // Restituisce solo la durata base
    }
}
\end{lstlisting}

\textbf{Analisi:}
\begin{itemize}
    \item Implementazione \textbf{concreta} del Component
    \item Valori \textbf{fissi}: costo €5.50, durata 5 minuti
    \item Tipo impostato a \texttt{"BASE"}
\end{itemize}

\subsection{Decorator: DecoratorAddON (Classe Astratta)}

\begin{lstlisting}[caption=DecoratorAddON.java - Decorator Base]
public abstract class DecoratorAddON extends Food {

    protected Food foodDecorato;  // COMPOSIZIONE: wrappa un Food

    protected DecoratorAddON(Food food) {
        this.foodDecorato = food;
        this.tipo = "ADDON";
    }

    // Metodi astratti per i valori aggiuntivi
    public abstract double getCostoPlus();
    public abstract int getDurataPlus();

    @Override
    public double getCosto() {
        if (foodDecorato == null) {
            return getCostoPlus();  // Standalone mode
        }
        return foodDecorato.getCosto() + getCostoPlus();  // DELEGATION + ADD
    }

    @Override
    public int getDurata() {
        if (foodDecorato == null) {
            return getDurataPlus();  // Standalone mode
        }
        return foodDecorato.getDurata() + getDurataPlus();  // DELEGATION + ADD
    }
}
\end{lstlisting}

\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=Punto Critico: Composizione]
L'attributo \texttt{foodDecorato} è il cuore del pattern:
\begin{itemize}
    \item Il Decorator \textbf{wrappa} un altro Food
    \item \textbf{Delega} a lui le operazioni base
    \item \textbf{Aggiunge} il proprio contributo
\end{itemize}
\end{tcolorbox}

\subsection{ConcreteDecorator: Cipolla}

\begin{lstlisting}[caption=Cipolla.java - ConcreteDecorator]
public class Cipolla extends DecoratorAddON {

    public Cipolla(Food food) {
        super(food);  // Passa il food da decorare al padre
    }

    @Override
    public String getDescrizione() {
        if (foodDecorato == null) {
            return "Cipolla";
        }
        return foodDecorato.getDescrizione() + ", Cipolla";  // Concatena
    }

    @Override
    public double getCostoPlus() {
        return 0.50;  // Aggiunge 50 centesimi
    }

    @Override
    public int getDurataPlus() {
        return 1;  // Aggiunge 1 minuto
    }
}
\end{lstlisting}

% ============================================================================
\section{Il Meccanismo di Wrapping}
% ============================================================================

\subsection{Esempio Passo-Passo}

Creiamo un Panino Doner Kebab con Cipolla e Patatine:

\begin{lstlisting}[caption=Esempio di decorazione multipla]
// Step 1: Crea il prodotto base
Food kebab = new PaninoDonerKebab();
// kebab.getCosto() = 5.50
// kebab.getDescrizione() = "Panino Doner Kebab"

// Step 2: Decora con Cipolla
kebab = new Cipolla(kebab);
// kebab.getCosto() = 5.50 + 0.50 = 6.00
// kebab.getDescrizione() = "Panino Doner Kebab, Cipolla"

// Step 3: Decora con Patatine
kebab = new Patatine(kebab);
// kebab.getCosto() = 6.00 + 1.50 = 7.50
// kebab.getDescrizione() = "Panino Doner Kebab, Cipolla, Patatine"
\end{lstlisting}

\subsection{Struttura in Memoria}

\begin{center}
\begin{tikzpicture}[
    node distance=0.8cm,
    box/.style={rectangle, draw, fill=green!20, text width=4cm, minimum height=1cm, align=center}
]
    \node[box, fill=orange!30] (patatine) {Patatine\\foodDecorato $\downarrow$};
    \node[box, fill=yellow!30, below=of patatine] (cipolla) {Cipolla\\foodDecorato $\downarrow$};
    \node[box, fill=blue!20, below=of cipolla] (panino) {PaninoDonerKebab\\(nessun wrapping)};
    
    \draw[->, thick] (patatine) -- (cipolla);
    \draw[->, thick] (cipolla) -- (panino);
\end{tikzpicture}
\end{center}

\subsection{Flusso di getCosto()}

Quando chiamiamo \texttt{kebab.getCosto()} su Patatine:

\begin{enumerate}
    \item \texttt{Patatine.getCosto()} chiama \texttt{foodDecorato.getCosto() + 1.50}
    \item \texttt{foodDecorato} è \texttt{Cipolla}, quindi chiama \texttt{Cipolla.getCosto()}
    \item \texttt{Cipolla.getCosto()} chiama \texttt{foodDecorato.getCosto() + 0.50}
    \item \texttt{foodDecorato} è \texttt{PaninoDonerKebab}, quindi chiama \texttt{PaninoDonerKebab.getCosto()}
    \item \texttt{PaninoDonerKebab.getCosto()} ritorna \texttt{5.50}
    \item Risale: \texttt{5.50 + 0.50 = 6.00}
    \item Risale: \texttt{6.00 + 1.50 = 7.50}
\end{enumerate}

% ============================================================================
\section{Integration: FoodFactory}
% ============================================================================

\subsection{Ruolo della Factory}

\texttt{FoodFactory} centralizza la logica di creazione e decorazione:

\begin{lstlisting}[caption=FoodFactory.applicaDecorator()]
public static Food applicaDecorator(Food food, String addOnClasse) {
    if (addOnClasse == null || food == null) {
        return food;
    }

    switch (addOnClasse) {
        case "Cipolla":
            return new Cipolla(food);           // Wrap con Cipolla
        case "SalsaYogurt":
            return new SalsaYogurt(food);       // Wrap con Salsa
        case "Patatine":
            return new Patatine(food);          // Wrap con Patatine
        case "MixVerdureGrigliate":
            return new MixVerdureGrigliate(food); // Wrap con Verdure
        default:
            return food;
    }
}
\end{lstlisting}

\subsection{Uso nel Controller}

\begin{lstlisting}[caption=Uso tipico nel Controller]
// Dall'input utente
String prodottoScelto = "PaninoDonerKebab";
List<String> addons = List.of("Cipolla", "Patatine");

// Creazione
Food food = FoodFactory.creaProdottoBase(prodottoScelto);

// Applicazione decoratori
for (String addon : addons) {
    food = FoodFactory.applicaDecorator(food, addon);
}

// Risultato finale
System.out.println(food.getDescrizione()); // "Panino Doner Kebab, Cipolla, Patatine"
System.out.println(food.getCosto());       // 7.50
\end{lstlisting}

% ============================================================================
\section{Vantaggi dell'Implementazione}
% ============================================================================

\begin{table}[h]
\centering
\begin{tabular}{|l|p{8cm}|}
\hline
\textbf{Vantaggio} & \textbf{Descrizione} \\
\hline
\textbf{Open/Closed} & Nuovi add-on senza modificare classi esistenti \\
\textbf{Single Responsibility} & Ogni decorator gestisce una sola responsabilità \\
\textbf{Composizione} & Combinazioni a runtime senza subclassing \\
\textbf{Flessibilità} & Ordine dei decorator intercambiabile \\
\textbf{Testabilità} & Ogni decorator testabile isolatamente \\
\hline
\end{tabular}
\caption{Vantaggi SOLID rispettati}
\end{table}

% ============================================================================
\section{Riepilogo Add-On Disponibili}
% ============================================================================

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|l|}
\hline
\textbf{Add-On} & \textbf{Costo Extra} & \textbf{Tempo Extra} & \textbf{Descrizione} \\
\hline
Cipolla & €0.50 & +1 min & Cipolla fresca \\
SalsaYogurt & €0.75 & +1 min & Salsa yogurt artigianale \\
Patatine & €1.50 & +3 min & Patatine fritte \\
MixVerdureGrigliate & €1.00 & +2 min & Verdure alla griglia \\
\hline
\end{tabular}
\caption{Tabella add-on e relativi costi/tempi}
\end{table}

% ============================================================================
\section{Conclusione}
% ============================================================================

L'implementazione del pattern Decorator nell'applicazione Habibi rispetta fedelmente la struttura definita dal GoF, utilizzando:

\begin{itemize}
    \item \textbf{Food} come Component astratto
    \item \textbf{DecoratorAddON} come Decorator astratto con la logica di delegation
    \item \textbf{Decorator concreti} che implementano \texttt{getCostoPlus()} e \texttt{getDurataPlus()}
    \item \textbf{FoodFactory} che semplifica la creazione e composizione
\end{itemize}

\begin{tcolorbox}[colback=habibiGold!10!white,colframe=habibiGold,title=Key Takeaway]
Il pattern Decorator permette di aggiungere add-on a un prodotto base in modo \textbf{dinamico} e \textbf{componibile}, evitando l'esplosione combinatoria delle sottoclassi e rispettando i principi SOLID.
\end{tcolorbox}

\end{document}
