\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{tikz}
\usepackage{amsmath}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric, shapes.multipart}

\geometry{margin=2.5cm}

% Configurazione listings per Java
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.97,0.97,0.97}
\definecolor{keywordcolor}{rgb}{0.0,0.0,0.7}

\lstdefinestyle{javastyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen}\itshape,
    keywordstyle=\color{keywordcolor}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    language=Java,
    morekeywords={var, record, sealed, permits, yield}
}

\lstset{style=javastyle}

\pagestyle{fancy}
\fancyhf{}
\rhead{Serializzazione Java}
\lhead{Habibi Shawarma}
\rfoot{Pagina \thepage}

\title{\textbf{Analisi della Serializzazione e Deserializzazione in Java} \\ 
\large Implementazione nel Progetto Habibi Shawarma \\
\vspace{0.5cm}
\normalsize Guida Completa per Principianti}
\author{Daniel Di Meo}
\date{15 Gennaio 2026}

\begin{document}

\maketitle
\tableofcontents
\newpage

% ==============================================================================
\section{Introduzione alla Serializzazione}
% ==============================================================================

\subsection{Definizione}

La \textbf{serializzazione} è il processo di conversione di un oggetto Java in una sequenza di byte, che può essere:
\begin{itemize}
    \item Salvata su disco (file)
    \item Trasmessa via rete
    \item Memorizzata in un database
\end{itemize}

La \textbf{deserializzazione} è il processo inverso: ricostruire l'oggetto originale a partire dalla sequenza di byte.

\subsection{Analogia del Mondo Reale}

Immagina di voler spedire un mobile IKEA:
\begin{enumerate}
    \item \textbf{Serializzazione}: Smonti il mobile e lo metti in una scatola piatta
    \item \textbf{Trasmissione}: Spedisci la scatola
    \item \textbf{Deserializzazione}: Il destinatario riassembla il mobile
\end{enumerate}

\begin{center}
\begin{tikzpicture}[
    box/.style={rectangle, draw, minimum width=2.5cm, minimum height=1cm, align=center, fill=blue!10},
    arrow/.style={-{Stealth[length=3mm]}, thick}
]
    \node[box] (obj) at (0,0) {\textbf{Oggetto} \\ in memoria};
    \node[box, fill=green!10] (bytes) at (5,0) {\textbf{Byte Stream} \\ 01101001...};
    \node[box, fill=orange!10] (storage) at (10,0) {\textbf{File/Rete} \\ persistente};
    
    \draw[arrow] (obj) -- node[above] {serialize} (bytes);
    \draw[arrow] (bytes) -- node[above] {write} (storage);
    
    \draw[arrow, dashed] (storage) to[bend right=30] node[below] {read + deserialize} (obj);
\end{tikzpicture}
\end{center}

\subsection{Perché Usare la Serializzazione?}

\begin{enumerate}
    \item \textbf{Persistenza}: Salvare lo stato di un oggetto su disco
    \item \textbf{Comunicazione Remota}: Inviare oggetti tra JVM diverse (RMI, socket)
    \item \textbf{Caching}: Memorizzare oggetti per riutilizzo futuro
    \item \textbf{Deep Copy}: Creare copie profonde di oggetti complessi
\end{enumerate}

% ==============================================================================
\section{L'Interfaccia Serializable}
% ==============================================================================

\subsection{Struttura}

\begin{lstlisting}[caption={Dichiarazione dell'interfaccia Serializable}]
package java.io;

public interface Serializable {
    // NESSUN METODO!
}
\end{lstlisting}

L'interfaccia \texttt{Serializable} è una \textbf{marker interface}: non contiene metodi, ma serve come "etichetta" per indicare che una classe può essere serializzata.

\subsection{Perché una Marker Interface?}

\begin{itemize}
    \item \textbf{Dichiarazione esplicita}: Il programmatore deve deliberatamente indicare che la classe è serializzabile
    \item \textbf{Sicurezza}: Non tutte le classi dovrebbero essere serializzate (es. risorse di sistema)
    \item \textbf{Controllo}: La JVM verifica questa interfaccia prima di serializzare
\end{itemize}

\begin{lstlisting}[caption={Classe NON serializzabile --- eccezione a runtime}]
public class NonSerializzabile {
    private int valore;
}

// Tentativo di serializzazione:
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("file.dat"));
out.writeObject(new NonSerializzabile()); // ERRORE!
// java.io.NotSerializableException: NonSerializzabile
\end{lstlisting}

% ==============================================================================
\section{Il Campo serialVersionUID}
% ==============================================================================

\subsection{Cos'è serialVersionUID?}

\begin{lstlisting}[caption={Dichiarazione del serialVersionUID}]
public class FoodBean implements Serializable {
    private static final long serialVersionUID = 1L;
    // ...
}
\end{lstlisting}

Il \texttt{serialVersionUID} è un \textbf{identificatore di versione} che garantisce la compatibilità tra la classe serializzata e quella deserializzata.

\subsection{Analisi Riga per Riga}

\begin{itemize}
    \item \texttt{private}: Accessibile solo dalla classe stessa
    \item \texttt{static}: Appartiene alla classe, non all'istanza (non viene serializzato!)
    \item \texttt{final}: Il valore non può cambiare
    \item \texttt{long}: Tipo numerico a 64 bit
    \item \texttt{serialVersionUID}: Nome convenzionale riconosciuto dalla JVM
    \item \texttt{= 1L}: Valore iniziale (la "L" indica un literal long)
\end{itemize}

\subsection{Perché è Importante?}

Immagina questo scenario:

\begin{lstlisting}[caption={Versione 1 della classe}]
public class Utente implements Serializable {
    private static final long serialVersionUID = 1L;
    private String nome;
    private String cognome;
}
// L'oggetto viene serializzato su file
\end{lstlisting}

\begin{lstlisting}[caption={Versione 2 della classe (modificata)}]
public class Utente implements Serializable {
    private static final long serialVersionUID = 1L; // STESSO valore
    private String nome;
    private String cognome;
    private int eta; // NUOVO campo aggiunto
}
// La deserializzazione funziona! 'eta' sara' 0 (default)
\end{lstlisting}

\begin{lstlisting}[caption={Versione 3 --- serialVersionUID diverso}]
public class Utente implements Serializable {
    private static final long serialVersionUID = 2L; // CAMBIATO!
    private String nome;
    private String cognome;
    private int eta;
}
// La deserializzazione FALLISCE!
// InvalidClassException: local class incompatible
\end{lstlisting}

\subsection{Best Practices}

\begin{enumerate}
    \item \textbf{Dichiara sempre} \texttt{serialVersionUID} esplicitamente
    \item \textbf{Incrementa} il valore quando fai modifiche incompatibili
    \item \textbf{Mantieni} lo stesso valore per modifiche compatibili (aggiunta campi)
    \item \textbf{Mai rimuovere} campi esistenti senza cambiare il UID
\end{enumerate}

% ==============================================================================
\section{Il Processo di Serializzazione}
% ==============================================================================

\subsection{ObjectOutputStream}

\begin{lstlisting}[caption={Serializzazione di un oggetto su file}]
// PASSO 1: Creare uno stream di output verso un file
FileOutputStream fileOut = new FileOutputStream("ordine.ser");

// PASSO 2: Avvolgere in un ObjectOutputStream
ObjectOutputStream out = new ObjectOutputStream(fileOut);

// PASSO 3: Scrivere l'oggetto
OrdineBean ordine = new OrdineBean();
ordine.setNumeroOrdine(123L);
out.writeObject(ordine);

// PASSO 4: Chiudere lo stream
out.close();
\end{lstlisting}

\textbf{Cosa succede internamente:}
\begin{enumerate}
    \item La JVM ispeziona la classe tramite reflection
    \item Verifica che implementi \texttt{Serializable}
    \item Controlla il \texttt{serialVersionUID}
    \item Converte ogni campo in byte
    \item Scrive i byte nel file con metadati della classe
\end{enumerate}

\subsection{ObjectInputStream}

\begin{lstlisting}[caption={Deserializzazione di un oggetto da file}]
// PASSO 1: Creare uno stream di input dal file
FileInputStream fileIn = new FileInputStream("ordine.ser");

// PASSO 2: Avvolgere in un ObjectInputStream
ObjectInputStream in = new ObjectInputStream(fileIn);

// PASSO 3: Leggere l'oggetto (richiede cast)
OrdineBean ordine = (OrdineBean) in.readObject();

// PASSO 4: Usare l'oggetto
System.out.println("Ordine #" + ordine.getNumeroOrdine());

// PASSO 5: Chiudere lo stream
in.close();
\end{lstlisting}

\subsection{Diagramma del Flusso}

\begin{center}
\begin{tikzpicture}[
    step/.style={rectangle, draw, minimum width=3cm, minimum height=0.8cm, align=center, fill=blue!10},
    arrow/.style={-{Stealth[length=2mm]}, thick}
]
    % Serialization
    \node[step] (obj1) at (0,0) {Oggetto Java};
    \node[step] (oos) at (0,-1.5) {ObjectOutputStream};
    \node[step] (fos) at (0,-3) {FileOutputStream};
    \node[step, fill=green!20] (file) at (0,-4.5) {File .ser};
    
    \draw[arrow] (obj1) -- (oos);
    \draw[arrow] (oos) -- (fos);
    \draw[arrow] (fos) -- (file);
    
    \node at (-2, -2.25) {\textbf{Serializzazione}};
    
    % Deserialization
    \node[step, fill=green!20] (file2) at (6,-4.5) {File .ser};
    \node[step] (fis) at (6,-3) {FileInputStream};
    \node[step] (ois) at (6,-1.5) {ObjectInputStream};
    \node[step] (obj2) at (6,0) {Oggetto Java};
    
    \draw[arrow] (file2) -- (fis);
    \draw[arrow] (fis) -- (ois);
    \draw[arrow] (ois) -- (obj2);
    
    \node at (8, -2.25) {\textbf{Deserializzazione}};
    
    % Connection
    \draw[arrow, dashed] (file) -- node[above] {trasporto/storage} (file2);
\end{tikzpicture}
\end{center}

% ==============================================================================
\section{Implementazione nel Progetto Habibi Shawarma}
% ==============================================================================

Nel progetto Habibi Shawarma, la serializzazione è implementata nei \textbf{Bean} del pattern BCE (Boundary-Control-Entity). I Bean sono oggetti di trasporto dati tra il layer grafico (Boundary) e il layer logico (Control).

\subsection{Bean Serializzabili del Progetto}

\begin{center}
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Classe} & \textbf{Package} & \textbf{Scopo} \\
\hline
FoodBean & crea\_ordine.beans & Trasporto dati prodotti \\
\hline
OrdineBean & crea\_ordine.beans & Trasporto dati ordine \\
\hline
VoucherBean & crea\_ordine.beans & Trasporto dati voucher \\
\hline
RiepilogoOrdineBean & crea\_ordine.beans & Riepilogo per la view \\
\hline
RigaOrdineBean & crea\_ordine.beans & Singola riga dell'ordine \\
\hline
CreaVoucherBean & crea\_voucher.beans & Dati per creazione voucher \\
\hline
\end{tabular}
\end{center}

\subsection{Esempio: FoodBean}

\begin{lstlisting}[caption={Implementazione completa di FoodBean}]
package org.example.use_cases.crea_ordine.beans;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public class FoodBean implements Serializable {
    
    // Identificatore di versione per la serializzazione
    private static final long serialVersionUID = 1L;
    
    // Costante per validazione (NON serializzata perche' static)
    private static final Set<String> TIPI_VALIDI = Set.of("BASE", "ADDON");
    
    // Campi serializzati
    private Long id;
    private String descrizione;
    private double costo;
    private int durata;
    private String tipo;
    private String classe;
    private List<String> addOnSelezionati;
    
    // Costruttore
    public FoodBean() {
        this.addOnSelezionati = new ArrayList<>();
    }
    
    // Getters e Setters con validazione...
}
\end{lstlisting}

\subsection{Cosa Viene Serializzato e Cosa No}

\begin{center}
\begin{tabular}{|l|c|p{6cm}|}
\hline
\textbf{Elemento} & \textbf{Serializzato?} & \textbf{Motivo} \\
\hline
\texttt{id, descrizione, costo...} & Sì & Campi di istanza \\
\hline
\texttt{serialVersionUID} & No & È \texttt{static} \\
\hline
\texttt{TIPI\_VALIDI} & No & È \texttt{static} \\
\hline
Campi \texttt{transient} & No & Esclusi esplicitamente \\
\hline
Metodi & No & Solo i dati vengono serializzati \\
\hline
\end{tabular}
\end{center}

\subsection{Esempio: RiepilogoOrdineBean con Classe Interna}

\begin{lstlisting}[caption={Bean con classe interna serializzabile}]
public class RiepilogoOrdineBean implements Serializable {
    
    private static final long serialVersionUID = 1L;
    
    private Long numeroOrdine;
    private List<RigaOrdineBean> righeOrdine;
    private double subtotale;
    private double sconto;
    private double totale;
    
    // Classe interna STATICA serializzabile
    public static class RigaOrdineBean implements Serializable {
        private static final long serialVersionUID = 1L;
        
        private String descrizione;
        private double prezzo;
        private int durata;
        
        // Getters e Setters...
    }
}
\end{lstlisting}

\textbf{Nota importante}: La classe interna \texttt{RigaOrdineBean} deve essere \texttt{static} per essere serializzabile indipendentemente, altrimenti conterrebbe un riferimento implicito alla classe esterna.

\subsection{Validazione nei Setter --- Fail-Fast}

\begin{lstlisting}[caption={Setter con validazione}]
public void setCosto(double costo) {
    if (costo < 0) {
        throw new ValidationException(
            "Il costo non puo' essere negativo: " + costo);
    }
    this.costo = costo;
}
\end{lstlisting}

La validazione nei setter garantisce che:
\begin{itemize}
    \item I dati siano validi \textbf{prima} di essere memorizzati
    \item Un oggetto deserializzato con dati corrotti fallirà immediatamente
    \item Il principio \textbf{Fail-Fast} viene rispettato
\end{itemize}

% ==============================================================================
\section{Utilizzo dei Bean nel Pattern BCE}
% ==============================================================================

\subsection{Flusso dei Dati}

\begin{center}
\begin{tikzpicture}[
    layer/.style={rectangle, draw, minimum width=4cm, minimum height=1.2cm, align=center},
    arrow/.style={-{Stealth[length=3mm]}, thick}
]
    \node[layer, fill=blue!20] (boundary) at (0,0) {\textbf{Boundary} \\ (GUI/CLI)};
    \node[layer, fill=green!20] (bean) at (5,0) {\textbf{Bean} \\ (FoodBean, OrdineBean)};
    \node[layer, fill=orange!20] (control) at (10,0) {\textbf{Control} \\ (Controller)};
    
    \draw[arrow] (boundary) -- node[above] {crea} (bean);
    \draw[arrow] (bean) -- node[above] {passa} (control);
    
    \draw[arrow, dashed] (control) to[bend right=30] node[below] {restituisce} (bean);
    \draw[arrow, dashed] (bean) to[bend right=30] node[below] {visualizza} (boundary);
\end{tikzpicture}
\end{center}

\subsection{Esempio di Flusso: Creazione Ordine}

\begin{enumerate}
    \item \textbf{GUI} crea un \texttt{FoodBean} con i dati inseriti dall'utente
    \item \texttt{FoodBean} viene passato al \texttt{CreaOrdineController}
    \item Il controller converte il Bean in Entity (\texttt{Food})
    \item Alla fine, il controller crea un \texttt{RiepilogoOrdineBean}
    \item Il \texttt{RiepilogoOrdineBean} viene restituito alla GUI per la visualizzazione
\end{enumerate}

\subsection{Perché Serializzare i Bean?}

Anche se nel progetto corrente i Bean non vengono effettivamente serializzati su file, implementare \texttt{Serializable} offre vantaggi:

\begin{enumerate}
    \item \textbf{Estendibilità}: In futuro si potrebbe voler salvare lo stato dell'ordine
    \item \textbf{Comunicazione Remota}: Se il sistema diventasse distribuito (es. client-server)
    \item \textbf{Caching}: Per memorizzare ordini frequenti
    \item \textbf{Testing}: Per creare snapshot di oggetti durante i test
\end{enumerate}

% ==============================================================================
\section{Il Modificatore transient}
% ==============================================================================

\subsection{Cos'è transient?}

Il modificatore \texttt{transient} indica che un campo \textbf{non deve essere serializzato}.

\begin{lstlisting}[caption={Uso del modificatore transient}]
public class SessionBean implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String username;
    private transient String password;  // NON serializzata!
    private transient Connection dbConn; // NON serializzabile
}
\end{lstlisting}

\subsection{Quando Usare transient}

\begin{itemize}
    \item \textbf{Dati sensibili}: Password, token, chiavi API
    \item \textbf{Risorse di sistema}: Connessioni DB, file handle, socket
    \item \textbf{Dati derivati}: Valori calcolabili da altri campi
    \item \textbf{Riferimenti a oggetti non serializzabili}
\end{itemize}

\subsection{Comportamento Durante la Deserializzazione}

\begin{lstlisting}[caption={Valori di default per campi transient}]
// Prima della serializzazione:
SessionBean bean = new SessionBean();
bean.setUsername("admin");
bean.setPassword("secret123");

// Dopo la deserializzazione:
SessionBean restored = (SessionBean) in.readObject();
restored.getUsername();  // "admin"
restored.getPassword();  // null (valore default per String)
\end{lstlisting}

\begin{center}
\begin{tabular}{|l|c|}
\hline
\textbf{Tipo} & \textbf{Valore Default} \\
\hline
\texttt{int, long, double...} & 0 \\
\hline
\texttt{boolean} & false \\
\hline
\texttt{Object} (riferimenti) & null \\
\hline
\end{tabular}
\end{center}

% ==============================================================================
\section{Considerazioni sulla Sicurezza}
% ==============================================================================

\subsection{Rischi della Deserializzazione}

La deserializzazione può essere \textbf{pericolosa} se:
\begin{itemize}
    \item Si deserializzano dati da fonti non fidate
    \item L'oggetto deserializzato esegue codice nel costruttore
    \item Vengono sfruttate librerie vulnerabili (gadget chains)
\end{itemize}

\subsection{Best Practices di Sicurezza}

\begin{enumerate}
    \item \textbf{Mai deserializzare dati non fidati} da utenti esterni
    \item \textbf{Validare} l'input dopo la deserializzazione
    \item \textbf{Usare whitelist} di classi ammesse
    \item \textbf{Considerare alternative}: JSON, XML, Protocol Buffers
\end{enumerate}

\begin{lstlisting}[caption={Validazione post-deserializzazione}]
OrdineBean ordine = (OrdineBean) in.readObject();

// Validazione esplicita dopo deserializzazione
if (ordine.getNumeroOrdine() == null || ordine.getNumeroOrdine() < 0) {
    throw new SecurityException("Dati ordine non validi");
}
\end{lstlisting}

% ==============================================================================
\section{Alternative alla Serializzazione Java}
% ==============================================================================

\subsection{Confronto tra Formati}

\begin{center}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Formato} & \textbf{Leggibile} & \textbf{Dimensione} & \textbf{Velocità} & \textbf{Interoperabile} \\
\hline
Java Serialization & No & Grande & Media & Solo Java \\
\hline
JSON & Sì & Media & Media & Sì \\
\hline
XML & Sì & Grande & Lenta & Sì \\
\hline
Protocol Buffers & No & Piccola & Veloce & Sì \\
\hline
\end{tabular}
\end{center}

\subsection{Quando Usare Quale}

\begin{itemize}
    \item \textbf{Java Serialization}: Comunicazione tra JVM Java, caching interno
    \item \textbf{JSON}: API REST, configurazione, leggibilità
    \item \textbf{XML}: Legacy systems, documenti strutturati
    \item \textbf{Protocol Buffers}: Performance critica, microservizi
\end{itemize}

% ==============================================================================
\section{Conclusioni}
% ==============================================================================

\subsection{Riepilogo}

\begin{enumerate}
    \item La \textbf{serializzazione} converte oggetti in byte e viceversa
    \item \texttt{Serializable} è una \textbf{marker interface} senza metodi
    \item \texttt{serialVersionUID} garantisce la \textbf{compatibilità tra versioni}
    \item I campi \texttt{static} e \texttt{transient} \textbf{non vengono serializzati}
    \item Nel progetto, i \textbf{Bean} implementano Serializable per estendibilità futura
\end{enumerate}

\subsection{Nel Progetto Habibi Shawarma}

I Bean serializzabili permettono:
\begin{itemize}
    \item Trasporto dati tra Boundary e Control (BCE)
    \item Potenziale persistenza su file system
    \item Possibile evoluzione verso architettura distribuita
    \item Validazione Fail-Fast nei setter
\end{itemize}

\end{document}
