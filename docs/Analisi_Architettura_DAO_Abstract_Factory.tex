% ============================================================================
%                    ANALISI ARCHITETTURA DAO - ABSTRACT FACTORY
%                           Progetto Habibi Shawarma
% ============================================================================
\documentclass[12pt,a4paper]{article}

% ======================== PACKAGES ========================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{mdframed}
\usepackage{tcolorbox}

% ======================== GEOMETRY ========================
\geometry{
    left=2.5cm,
    right=2.5cm,
    top=3cm,
    bottom=3cm
}

% ======================== COLORS ========================
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{keywordcolor}{rgb}{0.0,0.0,0.7}
\definecolor{stringcolor}{rgb}{0.6,0.0,0.0}
\definecolor{commentcolor}{rgb}{0.0,0.5,0.0}
\definecolor{primaryblue}{RGB}{0,82,155}
\definecolor{accentorange}{RGB}{230,126,34}

% ======================== LISTINGS JAVA ========================
\lstdefinestyle{javastyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{commentcolor}\itshape,
    keywordstyle=\color{keywordcolor}\bfseries,
    stringstyle=\color{stringcolor},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=8pt,
    numberstyle=\tiny\color{codegray},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    frame=single,
    rulecolor=\color{codegray},
    framerule=0.5pt,
    language=Java,
    morekeywords={var, yield, record, sealed, permits}
}

\lstset{style=javastyle}

% ======================== HYPERREF ========================
\hypersetup{
    colorlinks=true,
    linkcolor=primaryblue,
    filecolor=magenta,
    urlcolor=primaryblue,
    citecolor=primaryblue,
    pdftitle={Analisi Architettura DAO - Abstract Factory Pattern},
    pdfauthor={Progetto ISPW - Habibi Shawarma},
    pdfsubject={Design Patterns, Software Engineering},
    pdfkeywords={DAO, Abstract Factory, GoF, GRASP, SOLID}
}

% ======================== HEADER/FOOTER ========================
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\footnotesize Analisi Architettura DAO}
\fancyhead[R]{\footnotesize Progetto Habibi Shawarma}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% ======================== TITLE FORMAT ========================
\titleformat{\section}
    {\normalfont\Large\bfseries\color{primaryblue}}
    {\thesection}{1em}{}
\titleformat{\subsection}
    {\normalfont\large\bfseries\color{primaryblue!80}}
    {\thesubsection}{1em}{}
\titleformat{\subsubsection}
    {\normalfont\normalsize\bfseries\color{primaryblue!60}}
    {\thesubsubsection}{1em}{}

% ======================== CUSTOM BOXES ========================
\newtcolorbox{definitionbox}[1][]{
    colback=blue!5!white,
    colframe=primaryblue,
    fonttitle=\bfseries,
    title=#1,
    arc=3pt,
    boxrule=1pt
}

\newtcolorbox{notebox}[1][]{
    colback=orange!5!white,
    colframe=accentorange,
    fonttitle=\bfseries,
    title=#1,
    arc=3pt,
    boxrule=1pt
}

\newtcolorbox{codebox}{
    colback=backcolour,
    colframe=codegray,
    arc=2pt,
    boxrule=0.5pt
}

% ======================== DOCUMENT START ========================
\begin{document}

% ======================== TITLE PAGE ========================
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\Huge\bfseries\color{primaryblue} Analisi Tecnica Approfondita\par}
    \vspace{0.5cm}
    {\LARGE\color{primaryblue!80} Architettura DAO con\par}
    {\LARGE\color{primaryblue!80} Abstract Factory Pattern\par}
    
    \vspace{2cm}
    
    \begin{tikzpicture}
        \node[draw=primaryblue, line width=2pt, rounded corners=10pt, 
              minimum width=12cm, minimum height=4cm, fill=blue!5] {
            \begin{minipage}{10cm}
                \centering
                \Large\textbf{Progetto: Habibi Shawarma}\\[0.5cm]
                \large Sistema di Gestione Ordini\\
                con Persistenza Multi-Modalità
            \end{minipage}
        };
    \end{tikzpicture}
    
    \vspace{2cm}
    
    {\Large\textbf{Corso:} Ingegneria del Software e Progettazione Web\par}
    \vspace{0.5cm}
    {\large Anno Accademico 2025/2026\par}
    
    \vfill
    
    \begin{tabular}{ll}
        \textbf{Autore:} & Daniele Di Meo \\
        \textbf{Data:} & 13 Gennaio 2026 \\
        \textbf{Versione:} & 1.0 \\
    \end{tabular}
    
    \vspace{1cm}
\end{titlepage}

% ======================== TABLE OF CONTENTS ========================
\tableofcontents
\newpage

% ======================== ABSTRACT ========================
\section*{Abstract}
\addcontentsline{toc}{section}{Abstract}

Il presente documento fornisce un'analisi accademica approfondita dell'architettura di persistenza dei dati implementata nel progetto ``Habibi Shawarma''. L'architettura adotta il \textbf{Data Access Object (DAO) Pattern} in combinazione con l'\textbf{Abstract Factory Pattern} (GoF), implementando un sistema modulare e configurabile che supporta tre modalità di persistenza: Database Relazionale (H2), File System (CSV), e modalità Demo (in-memory).

\vspace{0.5cm}
\noindent\textbf{Parole chiave:} Abstract Factory, DAO Pattern, Template Method, GRASP, SOLID, Design Patterns, GoF.

\newpage

% ======================== SECTION 1 ========================
\section{Introduzione e Contesto Architetturale}

\subsection{Problema di Dominio}

In un'applicazione enterprise, la gestione della persistenza dei dati rappresenta una sfida progettuale significativa. I requisiti tipici includono:

\begin{itemize}[leftmargin=2cm]
    \item \textbf{Disaccoppiamento} tra logica di business e meccanismo di persistenza
    \item \textbf{Intercambiabilità} delle tecnologie di storage
    \item \textbf{Testabilità} attraverso implementazioni mock
    \item \textbf{Configurabilità} a runtime senza ricompilazione
\end{itemize}

\subsection{Soluzione Architetturale Adottata}

L'architettura implementata combina strategicamente tre Design Pattern GoF:

\begin{table}[H]
\centering
\caption{Design Pattern utilizzati nell'architettura}
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Pattern} & \textbf{Ruolo} & \textbf{Classe/i Coinvolta/e} \\
\midrule
Abstract Factory & Creazione famiglie DAO & \texttt{DAOFactoryAbstract}, \texttt{DAOFactory*} \\
Singleton & Istanza unica & \texttt{DAOFactoryAbstract.me}, \texttt{*DAODB.instance} \\
Template Method & Algoritmi CRUD & \texttt{DAODBAbstract<T>} \\
\bottomrule
\end{tabular}
\end{table}

% ======================== SECTION 2 ========================
\section{Design Pattern: Abstract Factory (GoF)}

\subsection{Definizione Formale}

\begin{definitionbox}[Definizione Gang of Four]
\textit{``Provide an interface for creating families of related or dependent objects without specifying their concrete classes.''}

\vspace{0.3cm}
\hfill --- Gamma, Helm, Johnson, Vlissides (1994)
\end{definitionbox}

\subsection{Struttura del Pattern nel Progetto}

La seguente figura illustra la struttura gerarchica dell'Abstract Factory implementata:

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=1.5cm,
    box/.style={rectangle, draw=primaryblue, fill=blue!10, 
                minimum width=3.5cm, minimum height=1cm, 
                text centered, rounded corners=3pt, font=\small},
    abstractbox/.style={rectangle, draw=primaryblue, fill=orange!10,
                        minimum width=4cm, minimum height=1.5cm,
                        text centered, rounded corners=3pt, font=\small},
    arrow/.style={->, >=stealth, thick, color=primaryblue}
]

% Abstract Factory
\node[abstractbox] (abstract) at (0,0) {
    \begin{tabular}{c}
        \textbf{DAOFactoryAbstract}\\
        \textit{<<abstract>>}
    \end{tabular}
};

% Concrete Factories
\node[box] (db) at (-4,-3) {\texttt{DAOFactoryDB}};
\node[box] (demo) at (0,-3) {\texttt{DAOFactoryDemo}};
\node[box] (fs) at (4,-3) {\texttt{DAOFactoryFS}};

% Arrows
\draw[arrow] (db) -- (abstract);
\draw[arrow] (demo) -- (abstract);
\draw[arrow] (fs) -- (abstract);

% Labels
\node[font=\scriptsize, color=codegray] at (-2,-1.5) {extends};
\node[font=\scriptsize, color=codegray] at (0,-1.5) {extends};
\node[font=\scriptsize, color=codegray] at (2,-1.5) {extends};

% Persistence labels
\node[font=\tiny, color=accentorange] at (-4,-3.8) {H2 Database};
\node[font=\tiny, color=accentorange] at (0,-3.8) {In-Memory};
\node[font=\tiny, color=accentorange] at (4,-3.8) {CSV Files};

\end{tikzpicture}
\caption{Gerarchia delle Factory nel sistema DAO}
\end{figure}

\subsection{Analisi del Codice Sorgente}

\subsubsection{Abstract Factory: DAOFactoryAbstract}

\begin{lstlisting}[caption={Implementazione della classe DAOFactoryAbstract}]
public abstract class DAOFactoryAbstract {

    private static DAOFactoryAbstract me = null;  // Singleton holder

    protected DAOFactoryAbstract() {
        // Costruttore protected: impedisce istanziazione diretta
    }

    public static synchronized DAOFactoryAbstract getInstance() 
            throws ResourceNotFoundException, PropertyException {
        if (me == null) {
            // Strategy Selection basata su configurazione esterna
            PersistenceTypeEnum persistenceType = PersistenceTypeEnum
                .getPersistenceTypeByValue(
                    PropertiesHandler.getInstance()
                        .getProperty("persistence_type")
                );
            
            if (persistenceType != null)
                switch (persistenceType) {
                    case DB   -> me = new DAOFactoryDB();
                    case DEMO -> me = new DAOFactoryDemo();
                    case FS   -> me = new DAOFactoryFS();
                    default   -> throw new PropertyException(...);
                }
            else
                throw new ResourceNotFoundException(...);
        }
        return me;
    }

    // Factory Methods astratti
    public abstract FoodDAOInterface getFoodDAO();
    public abstract OrdineDAOInterface getOrdineDAO();
    public abstract VoucherDAOInterface getVoucherDAO();
    public abstract UserDAOInterface getUserDAO();
}
\end{lstlisting}

\begin{notebox}[Analisi Tecnica]
\begin{itemize}[leftmargin=0.5cm]
    \item \textbf{Singleton:} \texttt{private static me} + \texttt{synchronized getInstance()}
    \item \textbf{Lazy Initialization:} Creazione solo alla prima chiamata
    \item \textbf{Protected Constructor:} Impedisce \texttt{new DAOFactoryAbstract()}
    \item \textbf{Configuration-driven:} Lettura da \texttt{PropertiesHandler}
\end{itemize}
\end{notebox}

\subsubsection{Concrete Factory: DAOFactoryDB}

\begin{lstlisting}[caption={Implementazione di DAOFactoryDB}]
public class DAOFactoryDB extends DAOFactoryAbstract {

    @Override
    public FoodDAOInterface getFoodDAO() {
        return FoodDAODB.getInstance();  // Singleton retrieval
    }

    @Override
    public OrdineDAOInterface getOrdineDAO() {
        return OrdineDAODB.getInstance();
    }

    @Override
    public VoucherDAOInterface getVoucherDAO() {
        return VoucherDAODB.getInstance();
    }

    @Override
    public UserDAOInterface getUserDAO() {
        return UserDAODB.getInstance();
    }
}
\end{lstlisting}

\subsubsection{Concrete Factory: DAOFactoryDemo}

\begin{lstlisting}[caption={Implementazione di DAOFactoryDemo}]
public class DAOFactoryDemo extends DAOFactoryAbstract {

    @Override
    public FoodDAOInterface getFoodDAO() {
        return new FoodDAODemo();  // Nuova istanza ogni volta
    }

    @Override
    public OrdineDAOInterface getOrdineDAO() {
        return new OrdineDAODemo();
    }
    
    // ... altri metodi
}
\end{lstlisting}

\begin{table}[H]
\centering
\caption{Confronto tra strategie di creazione DAO}
\begin{tabular}{@{}p{4cm}p{5cm}p{5cm}@{}}
\toprule
\textbf{Aspetto} & \textbf{DAOFactoryDB/FS} & \textbf{DAOFactoryDemo} \\
\midrule
Strategia & Singleton & Prototype \\
Memoria & Condivisa & Nuova istanza \\
Uso tipico & Produzione & Testing \\
Pro & Efficienza risorse & Isolamento test \\
Contro & Stato condiviso & Overhead creazione \\
\bottomrule
\end{tabular}
\end{table}

% ======================== SECTION 3 ========================
\section{Design Pattern: DAO (Data Access Object)}

\subsection{Definizione del Pattern}

Il DAO Pattern separa la logica di accesso ai dati dalla logica di business, fornendo un'interfaccia astratta per le operazioni CRUD (Create, Read, Update, Delete).

\subsection{Struttura delle Interfacce DAO}

\begin{lstlisting}[caption={Interfaccia FoodDAOInterface}]
public interface FoodDAOInterface {

    // CREATE
    void insert(Food food) throws DAOException, PropertyException, 
            ResourceNotFoundException, MissingAuthorizationException;

    // READ
    Food getFoodById(Long id) throws DAOException, ObjectNotFoundException, 
            PropertyException, ResourceNotFoundException;

    List<Food> getAllFoodBase() throws DAOException, PropertyException;

    List<Food> getAllAddOn() throws DAOException, PropertyException;

    // UPDATE
    void update(Food food) throws DAOException, PropertyException, 
            ResourceNotFoundException, MissingAuthorizationException;

    // DELETE
    void delete(Food food) throws DAOException, PropertyException, 
            ResourceNotFoundException;
}
\end{lstlisting}

\begin{table}[H]
\centering
\caption{Mapping operazioni CRUD}
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Operazione} & \textbf{Metodo} & \textbf{SQL Equivalente} & \textbf{Eccezione Principale} \\
\midrule
Create & \texttt{insert(T)} & INSERT INTO & \texttt{DAOException} \\
Read (one) & \texttt{getXxxById(Long)} & SELECT ... WHERE & \texttt{ObjectNotFoundException} \\
Read (many) & \texttt{getAllXxx()} & SELECT * & \texttt{DAOException} \\
Update & \texttt{update(T)} & UPDATE ... SET & \texttt{DAOException} \\
Delete & \texttt{delete(T)} & DELETE WHERE & \texttt{DAOException} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Implementazione FoodDAODB}

\begin{lstlisting}[caption={Implementazione FoodDAODB con Template Method}]
public class FoodDAODB extends DAODBAbstract<Food> 
        implements FoodDAOInterface {

    private static final String FOOD = "FOOD";
    private static final String ID = "id";
    
    protected static FoodDAOInterface instance;

    private FoodDAODB() {}

    public static synchronized FoodDAOInterface getInstance() {
        if (instance == null) {
            instance = new FoodDAODB();
        }
        return instance;
    }

    @Override
    public Food getFoodById(Long id) throws DAOException, ... {
        return getQuery(
            FOOD,
            List.of(ID),
            List.of(id),
            List.of()
        );
    }

    @Override
    public List<Food> getAllFoodBase() throws DAOException, ... {
        return getListQuery(
            FOOD,
            List.of(TIPO),
            List.of("BASE"),
            List.of(),
            List.of(),
            Boolean.FALSE
        );
    }

    @Override
    protected Food queryObjectBuilder(ResultSet rs, List<Object> objects) 
            throws SQLException, DAOException {
        Long foodId = rs.getLong(ID);
        String classe = rs.getString(CLASSE);
        return createFoodInstance(foodId, classe);
    }

    private Food createFoodInstance(Long id, String classe) {
        return switch (classe) {
            case "PaninoDonerKebab"  -> new PaninoDonerKebab(id);
            case "PiadinaDonerKebab" -> new PiadinaDonerKebab(id);
            case "KebabAlPiatto"     -> new KebabAlPiatto(id);
            default -> new PaninoDonerKebab(id);
        };
    }
}
\end{lstlisting}

% ======================== SECTION 4 ========================
\section{Design Pattern: Template Method (GoF)}

\subsection{Definizione}

\begin{definitionbox}[Definizione Gang of Four]
\textit{``Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.''}
\end{definitionbox}

\subsection{Implementazione in DAODBAbstract<T>}

\begin{lstlisting}[caption={Classe astratta DAODBAbstract con Template Method}]
public abstract class DAODBAbstract<T> {

    // ============ TEMPLATE METHODS ============
    
    protected T getQuery(String table, List<String> identifiers, 
                         List<Object> identifiersValues, 
                         List<Object> objects) throws DAOException {
        
        // STEP 1: Costruzione query SQL
        String query = String.format(
            "select * from %s where %s", 
            table, 
            andStringBuilder(identifiers, identifiersValues)
        );
        
        // STEP 2: Ottenimento connessione
        Connection conn = DBConnection.getInstance().getConnection();
        
        // STEP 3: Esecuzione query
        try (PreparedStatement stmt = createStatement(conn, query, ...);
             ResultSet rs = stmt.executeQuery()) {
            if (rs.first()) {
                // STEP 4: Delega a HOOK METHOD
                return queryObjectBuilder(rs, objects);
            } else {
                throw new ObjectNotFoundException(...);
            }
        }
    }

    protected List<T> getListQuery(String table, ...) {
        // Template per liste...
    }

    protected void insertQuery(String table, List<Object> values) {
        // Template per insert...
    }

    protected void updateQuery(String table, ...) {
        // Template per update...
    }

    // ============ HOOK METHODS (abstract) ============
    
    protected abstract T queryObjectBuilder(
        ResultSet rs, 
        List<Object> objects
    ) throws SQLException, DAOException;

    protected abstract String setGetListQueryIdentifiersValue(
        T t, 
        int valueNumber
    ) throws DAOException;

    // ============ HELPER METHODS (private) ============
    
    private StringBuilder andStringBuilder(
            List<String> names, 
            List<Object> values) {
        StringBuilder builder = new StringBuilder();
        for (String s : names) {
            builder.append(s).append(" = ? and ");
        }
        builder.delete(builder.length() - 5, builder.length());
        return builder;
    }
}
\end{lstlisting}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=1cm,
    box/.style={rectangle, draw=primaryblue, fill=blue!10, 
                minimum width=4.5cm, minimum height=0.8cm, 
                text centered, font=\small},
    abstractbox/.style={rectangle, draw=accentorange, fill=orange!10,
                        minimum width=5cm, minimum height=1.2cm,
                        text centered, font=\small},
    arrow/.style={->, >=stealth, thick}
]

% DAODBAbstract
\node[abstractbox] (template) at (0,0) {
    \begin{tabular}{c}
        \textbf{DAODBAbstract<T>}\\
        \textit{Template Class}
    \end{tabular}
};

% Methods
\node[box, fill=green!10] (getquery) at (0,-1.8) {\texttt{getQuery()} - Template};
\node[box, fill=green!10] (getlist) at (0,-2.8) {\texttt{getListQuery()} - Template};
\node[box, fill=yellow!20] (builder) at (0,-4) {\texttt{queryObjectBuilder()} - Hook};

% Concrete classes
\node[box] (food) at (-4,-6) {\texttt{FoodDAODB}};
\node[box] (ordine) at (0,-6) {\texttt{OrdineDAODB}};
\node[box] (voucher) at (4,-6) {\texttt{VoucherDAODB}};

% Arrows
\draw[arrow] (food) -- (-4,-4.5) -- (builder);
\draw[arrow] (ordine) -- (builder);
\draw[arrow] (voucher) -- (4,-4.5) -- (builder);

% Labels
\node[font=\scriptsize, color=codegray] at (-3,-5.2) {implements};
\node[font=\scriptsize, color=codegray] at (0,-5) {implements};
\node[font=\scriptsize, color=codegray] at (3,-5.2) {implements};

\end{tikzpicture}
\caption{Struttura del Template Method Pattern}
\end{figure}

% ======================== SECTION 5 ========================
\section{Analisi GRASP}

\subsection{Applicazione dei Principi}

I principi GRASP (General Responsibility Assignment Software Patterns) sono applicati sistematicamente nell'architettura:

\begin{table}[H]
\centering
\caption{Applicazione principi GRASP}
\begin{tabular}{@{}p{3.5cm}p{5cm}p{5cm}@{}}
\toprule
\textbf{Principio} & \textbf{Applicazione} & \textbf{Componente} \\
\midrule
Creator & Factory crea DAO appropriati & \texttt{DAOFactoryAbstract} \\
Information Expert & DAO conosce gestione entità & \texttt{FoodDAODB} \\
Low Coupling & Client dipende da interfacce & Controller $\rightarrow$ \texttt{*DAOInterface} \\
High Cohesion & Una responsabilità per DAO & \texttt{OrdineDAO} $\rightarrow$ \texttt{Ordine} \\
Polymorphism & Scelta persistenza polimorfica & Factory concrete \\
Protected Variations & Persistenza nascosta & \texttt{*DAOInterface} \\
Indirection & Factory come intermediario & \texttt{DAOFactoryAbstract} \\
Pure Fabrication & DAO non è concetto dominio & Tutti i DAO \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Low Coupling - Analisi Dettagliata}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=1.5cm,
    box/.style={rectangle, draw=primaryblue, fill=blue!10, 
                minimum width=3.5cm, minimum height=0.8cm, 
                text centered, font=\small},
    interface/.style={rectangle, draw=accentorange, dashed, fill=orange!10,
                      minimum width=4cm, minimum height=0.8cm,
                      text centered, font=\small},
    arrow/.style={->, >=stealth, thick, dashed}
]

% Client
\node[box] (client) at (0,0) {CLIENT CODE};

% Interface
\node[interface] (interface) at (0,-2) {
    \texttt{FoodDAOInterface} \textit{<<interface>>}
};

% Implementations
\node[box] (db) at (-4,-4) {\texttt{FoodDAODB}};
\node[box] (demo) at (0,-4) {\texttt{FoodDAODemo}};
\node[box] (fs) at (4,-4) {\texttt{FoodDAOFS}};

% Arrows
\draw[arrow, color=primaryblue] (client) -- node[right, font=\scriptsize]{dipende da} (interface);
\draw[->, >=stealth, thick] (db) -- (interface);
\draw[->, >=stealth, thick] (demo) -- (interface);
\draw[->, >=stealth, thick] (fs) -- (interface);

% Labels
\node[font=\scriptsize, color=codegray] at (-2.5,-3) {implements};

% Benefit box
\node[draw=green!50!black, fill=green!10, rounded corners, 
      minimum width=8cm, font=\small] at (0,-5.5) {
    \textbf{Beneficio:} Il client NON conosce l'implementazione concreta
};

\end{tikzpicture}
\caption{Principio Low Coupling}
\end{figure}

\subsection{High Cohesion - Analisi Dettagliata}

\begin{table}[H]
\centering
\caption{Responsabilità della classe FoodDAODB}
\begin{tabular}{@{}cl@{}}
\toprule
\textbf{Status} & \textbf{Responsabilità} \\
\midrule
\checkmark & \texttt{insert(Food)} $\rightarrow$ INSERT food nel DB \\
\checkmark & \texttt{delete(Food)} $\rightarrow$ DELETE food dal DB \\
\checkmark & \texttt{update(Food)} $\rightarrow$ UPDATE food nel DB \\
\checkmark & \texttt{getFoodById(Long)} $\rightarrow$ SELECT BY ID \\
\checkmark & \texttt{getAllFoodBase()} $\rightarrow$ SELECT WHERE tipo='BASE' \\
\checkmark & \texttt{queryObjectBuilder()} $\rightarrow$ Mapping ResultSet \\
\midrule
$\times$ & NON gestisce: User, Ordine, Voucher \\
$\times$ & NON contiene: Logica di business \\
$\times$ & NON espone: Dettagli SQL al client \\
\bottomrule
\end{tabular}
\end{table}

% ======================== SECTION 6 ========================
\section{Conformità ai Principi SOLID}

\begin{table}[H]
\centering
\caption{Analisi conformità SOLID}
\begin{tabular}{@{}clp{7cm}@{}}
\toprule
\textbf{Principio} & \textbf{Conf.} & \textbf{Analisi} \\
\midrule
\textbf{S}ingle Responsibility & \checkmark & Ogni DAO gestisce una sola entità \\
\textbf{O}pen/Closed & \checkmark & Aperto (nuove factory) / Chiuso (no modifiche) \\
\textbf{L}iskov Substitution & \checkmark & Sottoclassi sostituibili senza problemi \\
\textbf{I}nterface Segregation & \checkmark & Interfacce specifiche per entità \\
\textbf{D}ependency Inversion & \checkmark & Client dipende da \texttt{*DAOInterface} \\
\bottomrule
\end{tabular}
\end{table}

% ======================== SECTION 7 ========================
\section{Valutazione Critica dell'Architettura}

\subsection{Punti di Forza}

\begin{table}[H]
\centering
\caption{Valutazione punti di forza}
\begin{tabular}{@{}lcp{6cm}@{}}
\toprule
\textbf{Criterio} & \textbf{Voto} & \textbf{Motivazione} \\
\midrule
Estensibilità & 5/5 & Nuova persistenza = solo nuova Factory + DAO \\
Manutenibilità & 5/5 & Modifiche isolate al tipo di persistenza \\
Testabilità & 5/5 & \texttt{DAOFactoryDemo} per test senza DB \\
Configurabilità & 4/5 & Switch via file properties \\
Riusabilità & 4/5 & \texttt{DAODBAbstract} riutilizza logica SQL \\
Separation of Concerns & 5/5 & Persistenza completamente isolata \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Aree di Possibile Miglioramento}

\begin{table}[H]
\centering
\caption{Aree di miglioramento}
\begin{tabular}{@{}p{3cm}p{4cm}p{5cm}@{}}
\toprule
\textbf{Area} & \textbf{Situazione Attuale} & \textbf{Suggerimento} \\
\midrule
Singleton Reset & No metodo per reset & Aggiungere \texttt{resetInstance()} \\
Demo Consistency & Nuove istanze ogni volta & Considerare Singleton \\
Exception Handling & Molte checked exceptions & Valutare wrapper exception \\
Connection Pooling & Connessione singola & Implementare pool \\
\bottomrule
\end{tabular}
\end{table}

% ======================== SECTION 8 ========================
\section{Conclusioni}

L'architettura DAO implementata nel progetto ``Habibi Shawarma'' rappresenta un esempio accademico eccellente di applicazione combinata dei Design Pattern GoF. La scelta di utilizzare \textbf{Abstract Factory} per la creazione delle famiglie di DAO, \textbf{Singleton} per la gestione delle istanze, e \textbf{Template Method} per il riuso del codice SQL, dimostra una profonda comprensione dei principi di progettazione software.

\vspace{0.5cm}
I benefici principali di questa architettura sono:

\begin{enumerate}
    \item \textbf{Flessibilità}: Cambio trasparente tra DB, File System e Demo
    \item \textbf{Testabilità}: Test unitari semplificati senza infrastruttura
    \item \textbf{Manutenibilità}: Modifiche localizzate e prevedibili
    \item \textbf{Scalabilità}: Facile aggiunta di nuove entità o tipi di persistenza
\end{enumerate}

\vspace{0.3cm}
L'architettura rispetta pienamente i principi GRASP e SOLID, ponendosi come riferimento per implementazioni enterprise di livello professionale.

% ======================== REFERENCES ========================
\section*{Riferimenti Bibliografici}
\addcontentsline{toc}{section}{Riferimenti Bibliografici}

\begin{enumerate}[label={[\arabic*]}]
    \item Gamma, E., Helm, R., Johnson, R., \& Vlissides, J. (1994). \textit{Design Patterns: Elements of Reusable Object-Oriented Software}. Addison-Wesley.
    
    \item Larman, C. (2004). \textit{Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and Iterative Development} (3rd ed.). Prentice Hall.
    
    \item Martin, R. C. (2008). \textit{Clean Code: A Handbook of Agile Software Craftsmanship}. Prentice Hall.
    
    \item Fowler, M. (2002). \textit{Patterns of Enterprise Application Architecture}. Addison-Wesley.
    
    \item Oracle. (n.d.). \textit{Core J2EE Patterns - Data Access Object}. Java EE Documentation.
\end{enumerate}

\end{document}
