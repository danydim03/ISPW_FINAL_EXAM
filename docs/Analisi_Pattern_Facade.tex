\documentclass[12pt,a4paper]{article}

% ==================== PACKAGES ====================
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{tikz}
\usetikzlibrary{shapes.multipart, positioning, arrows.meta, fit, calc}
\usepackage{fancyhdr}
\usepackage{parskip}
\usepackage{enumitem}
\usepackage{float}

% ==================== GEOMETRY ====================
\geometry{margin=2.5cm}

% ==================== LISTINGS STYLE ====================
\definecolor{codegreen}{rgb}{0.0,0.5,0.0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.97,0.97,0.97}
\definecolor{javablue}{rgb}{0.0,0.0,0.6}
\definecolor{javaorange}{rgb}{0.8,0.4,0.0}

\lstdefinestyle{javastyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen}\itshape,
    keywordstyle=\color{javablue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=8pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    frame=single,
    framerule=0.3pt,
    language=Java,
    morekeywords={String, List, User, Session, Token, synchronized, Ordine, Voucher, Food, throws}
}
\lstset{style=javastyle}

% ==================== HEADER/FOOTER ====================
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textit{Analisi Pattern Facade}}
\fancyhead[R]{\textit{Habibi Shawarma}}
\fancyfoot[C]{\thepage}

% ==================== DOCUMENT ====================
\begin{document}

% ==================== TITLE PAGE ====================
\begin{titlepage}
    \centering
    \vspace*{2cm}
    {\Huge\bfseries Analisi Architetturale del\\[0.3cm] Pattern Facade\par}
    \vspace{1cm}
    {\Large Implementazione nei Use Case del Sistema\\Habibi Shawarma\par}
    \vspace{2cm}
    {\large Progetto: \textbf{Habibi Shawarma}\par}
    \vspace{0.5cm}
    {\large Corso: Ingegneria del Software e Progettazione Web\par}
    \vspace{2cm}
    \rule{\textwidth}{0.4pt}
    \vspace{0.5cm}
    
    \textbf{Pattern Analizzati:}
    \begin{itemize}[label=$\bullet$, leftmargin=3cm]
        \item GoF Facade Pattern
        \item BCE (Boundary-Control-Entity)
        \item GRASP Principles
    \end{itemize}
    
    \vspace{1cm}
    {\large\today\par}
    \vfill
\end{titlepage}

% ==================== TABLE OF CONTENTS ====================
\tableofcontents
\newpage

% ==================== PART I: FONDAMENTI TEORICI ====================
\part{Fondamenti Teorici}

\section{Il Pattern Facade: Definizione GoF}

\subsection{Definizione Formale}

Il pattern \textbf{Facade} appartiene alla categoria dei pattern \textbf{strutturali} nel catalogo Gang of Four (GoF). La definizione originale recita:

\begin{quote}
\textit{``Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.''}

--- Gamma, Helm, Johnson, Vlissides (1994)
\end{quote}

\subsection{Intento del Pattern}

L'intento principale del pattern Facade è quello di fornire un'\textbf{interfaccia semplificata} a un sottosistema complesso. Questo pattern nasconde la complessità del sottosistema dietro un'unica classe che funge da ``facciata'', rendendo il sistema più facile da usare per i client esterni.

\subsection{Struttura Generale}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    class/.style={rectangle, draw, minimum width=2.8cm, minimum height=1cm, font=\small, fill=white},
    facade/.style={rectangle, draw, minimum width=3.5cm, minimum height=1.5cm, font=\small, fill=yellow!20, thick},
    client/.style={rectangle, draw, minimum width=2cm, minimum height=1cm, font=\small, fill=blue!10},
    arrow/.style={-{Stealth[length=3mm]}, thick},
    dasharrow/.style={-{Stealth[length=3mm]}, dashed}
]

% Client
\node[client] (client) at (-4,0) {Client};

% Facade
\node[facade] (facade) at (0,0) {\textbf{Facade}};

% Subsystem
\node[class] (sub1) at (4,1.5) {SubsystemA};
\node[class] (sub2) at (4,0) {SubsystemB};
\node[class] (sub3) at (4,-1.5) {SubsystemC};

% Subsystem box
\draw[dashed, thick, rounded corners] (2.5,-2.5) rectangle (5.5,2.5);
\node at (4,-2.8) {\textit{Sottosistema}};

% Arrows
\draw[arrow] (client) -- (facade);
\draw[arrow] (facade) -- (sub1);
\draw[arrow] (facade) -- (sub2);
\draw[arrow] (facade) -- (sub3);
\draw[dasharrow] (sub1) -- (sub2);
\draw[dasharrow] (sub2) -- (sub3);

\end{tikzpicture}
\caption{Struttura generale del Pattern Facade (GoF)}
\end{figure}

\subsection{Partecipanti}

\begin{description}
    \item[\textbf{Facade}] Conosce quali classi del sottosistema sono responsabili per una richiesta. Delega le richieste del client agli oggetti appropriati del sottosistema.
    
    \item[\textbf{Subsystem classes}] Implementano le funzionalità del sottosistema. Gestiscono il lavoro assegnato dall'oggetto Facade. Non hanno alcuna conoscenza del Facade---cioè, non mantengono riferimenti ad esso.
    
    \item[\textbf{Client}] Comunica con il sottosistema attraverso il Facade invece di interagire direttamente con le classi del sottosistema.
\end{description}

\subsection{Conseguenze dell'Applicazione}

Il pattern Facade offre i seguenti benefici:

\begin{enumerate}
    \item \textbf{Isolamento dei client dalla complessità}: I client non devono conoscere i dettagli interni del sottosistema.
    
    \item \textbf{Accoppiamento debole}: Il Facade promuove un accoppiamento debole tra il sottosistema e i suoi client.
    
    \item \textbf{Non impedisce l'accesso diretto}: I client possono comunque accedere direttamente alle classi del sottosistema se necessario.
    
    \item \textbf{Semplificazione dell'API}: Riduce il numero di oggetti con cui i client devono interagire.
\end{enumerate}

\subsection{Relazione con GRASP}

Il pattern Facade incarna diversi principi GRASP:

\begin{table}[H]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Principio GRASP} & \textbf{Come viene applicato} \\
\midrule
\textbf{Low Coupling} & I client dipendono solo dal Facade, non dal sottosistema \\
\textbf{Controller} & Il Facade coordina le operazioni del sottosistema \\
\textbf{Indirection} & Aggiunge un livello di indirezione per disaccoppiare \\
\textbf{Protected Variations} & Protegge i client dalle variazioni del sottosistema \\
\bottomrule
\end{tabular}
\caption{Principi GRASP applicati dal Pattern Facade}
\end{table}

% ==================== SECTION: BCE ====================
\section{Integrazione con l'Architettura BCE}

\subsection{Il Pattern BCE}

L'architettura \textbf{BCE} (Boundary-Control-Entity), nota anche come ECB o Robustness Diagram, è un pattern architetturale che suddivide le responsabilità in tre categorie:

\begin{description}
    \item[\textbf{Boundary}] Rappresenta l'interfaccia con il mondo esterno (GUI, CLI, API). Gestisce l'input/output con gli attori.
    
    \item[\textbf{Control}] Contiene la logica applicativa. Coordina il flusso delle operazioni tra Boundary e Entity.
    
    \item[\textbf{Entity}] Rappresenta gli oggetti di dominio. Contiene dati e logica di business intrinseca.
\end{description}

\subsection{Posizionamento del Facade in BCE}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    boundary/.style={circle, draw, minimum size=1.5cm, fill=green!20},
    control/.style={ellipse, draw, minimum width=2cm, minimum height=1.2cm, fill=yellow!20},
    entity/.style={rectangle, draw, minimum width=1.5cm, minimum height=1cm, fill=blue!20},
    facade/.style={rectangle, draw, minimum width=2.5cm, minimum height=1cm, fill=orange!20, thick},
    arrow/.style={-{Stealth[length=3mm]}, thick}
]

% Layers
\node at (-5,0) {\textbf{LAYER}};
\node at (-5,-1.5) {Presentation};
\node at (-5,-3.5) {Application};
\node at (-5,-5.5) {Domain};

\draw[dashed] (-4,-0.5) -- (6,-0.5);
\draw[dashed] (-4,-2.5) -- (6,-2.5);
\draw[dashed] (-4,-4.5) -- (6,-4.5);

% Boundary
\node[boundary] (gui) at (0,-1.5) {GUI};
\node[boundary] (cli) at (2,-1.5) {CLI};

% Facade
\node[facade] (facade) at (1,-3.5) {\textbf{Facade}};

% Control
\node[control] (ctrl) at (4,-3.5) {Controller};

% Entity
\node[entity] (ord) at (0,-5.5) {Ordine};
\node[entity] (usr) at (2,-5.5) {User};
\node[entity] (vou) at (4,-5.5) {Voucher};

% Arrows
\draw[arrow] (gui) -- (facade);
\draw[arrow] (cli) -- (facade);
\draw[arrow] (facade) -- (ctrl);
\draw[arrow] (ctrl) -- (ord);
\draw[arrow] (ctrl) -- (usr);
\draw[arrow] (ctrl) -- (vou);

\end{tikzpicture}
\caption{Posizionamento del Facade nell'architettura BCE}
\end{figure}

Il Facade si posiziona al confine tra il layer di presentazione (Boundary) e il layer applicativo (Control), fungendo da:
\begin{itemize}
    \item \textbf{Punto di ingresso unificato} per le operazioni dello Use Case
    \item \textbf{Gestore dell'autenticazione/autorizzazione} tramite SessionManager
    \item \textbf{Convertitore} tra Bean (DTO) e Entity
\end{itemize}

% ==================== PART II: IMPLEMENTAZIONE ====================
\newpage
\part{Implementazione nel Progetto Habibi Shawarma}

\section{Panoramica delle Classi Facade}

Il progetto Habibi Shawarma implementa \textbf{cinque Facade}, ciascuno dedicato a un Use Case specifico:

\begin{table}[H]
\centering
\begin{tabular}{@{}llc@{}}
\toprule
\textbf{Facade} & \textbf{Use Case} & \textbf{Metodi} \\
\midrule
\texttt{CreaOrdineFacade} & Creazione ordini & 10 \\
\texttt{CreaVoucherFacade} & Creazione voucher & 1 \\
\texttt{StoricoOrdiniFacade} & Storico ordini cliente & 1 \\
\texttt{UsaVoucherFacade} & Applicazione voucher & 6 \\
\texttt{VisualizzaOrdiniFacade} & Gestione ordini (Admin) & 2 \\
\bottomrule
\end{tabular}
\caption{Elenco dei Facade nel progetto}
\end{table}

\subsection{Diagramma delle Classi Complessivo}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    facade/.style={rectangle split, rectangle split parts=2, draw, minimum width=4.5cm, font=\small, fill=yellow!15},
    ctrl/.style={rectangle split, rectangle split parts=2, draw, minimum width=4.5cm, font=\small, fill=blue!10},
    sm/.style={rectangle, draw, minimum width=3cm, minimum height=0.8cm, font=\small, fill=orange!15},
    arrow/.style={-{Stealth[length=2.5mm]}, thick},
    scale=0.85, transform shape
]

% SessionManager
\node[sm] (sm) at (0,4) {SessionManager};

% Facades
\node[facade] (f1) at (-5,1.5) {\textbf{CreaOrdineFacade}\nodepart{second}\footnotesize 10 metodi};
\node[facade] (f2) at (0,1.5) {\textbf{CreaVoucherFacade}\nodepart{second}\footnotesize 1 metodo};
\node[facade] (f3) at (5,1.5) {\textbf{UsaVoucherFacade}\nodepart{second}\footnotesize 6 metodi};
\node[facade] (f4) at (-2.5,-0.5) {\textbf{StoricoOrdiniFacade}\nodepart{second}\footnotesize 1 metodo};
\node[facade] (f5) at (2.5,-0.5) {\textbf{VisualizzaOrdiniFacade}\nodepart{second}\footnotesize 2 metodi};

% Controllers
\node[ctrl] (c1) at (-5,-2.5) {\textbf{CreaOrdineController}\nodepart{second}\footnotesize BCE Control};
\node[ctrl] (c2) at (0,-2.5) {\textbf{CreaVoucherController}\nodepart{second}\footnotesize BCE Control};
\node[ctrl] (c3) at (5,-2.5) {\textbf{UsaVoucherController}\nodepart{second}\footnotesize BCE Control};

% Arrows to SessionManager
\draw[arrow] (f1.north) -- ++(0,0.5) -| (sm.south);
\draw[arrow] (f2) -- (sm);
\draw[arrow] (f4.north) -- ++(0,0.3) -| (sm.south);

% Arrows to Controllers
\draw[arrow] (f1) -- (c1);
\draw[arrow] (f2) -- (c2);
\draw[arrow] (f3) -- (c3);

\end{tikzpicture}
\caption{Architettura Facade-Controller del sistema}
\end{figure}

% ==================== CREA ORDINE FACADE ====================
\newpage
\section{CreaOrdineFacade --- Analisi Dettagliata}

\subsection{Descrizione Generale}

Il \texttt{CreaOrdineFacade} è il Facade più complesso del sistema. Gestisce l'intero flusso di creazione di un ordine, dalla selezione dei prodotti fino alla conferma finale.

\subsection{Struttura della Classe}

\begin{lstlisting}[caption={Dichiarazione della classe CreaOrdineFacade}]
public class CreaOrdineFacade {

    private final CreaOrdineController controller;
    private final org.example.model.user.User sessionUser;

    public CreaOrdineFacade(String tokenKey) 
            throws MissingAuthorizationException {
        this.sessionUser = SessionManager.getInstance()
            .getSessionUserByTokenKey(tokenKey);
        if (sessionUser == null || 
            sessionUser.getRole() == null || 
            sessionUser.getRole().getClienteRole() == null) {
            throw new MissingAuthorizationException(
                "Accesso negato: token non autorizzato");
        }
        this.controller = new CreaOrdineController();
    }
}
\end{lstlisting}

\subsubsection{Attributi}

\begin{table}[H]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Attributo} & \textbf{Tipo} & \textbf{Descrizione} \\
\midrule
\texttt{controller} & \texttt{CreaOrdineController} & Controller applicativo delegato \\
\texttt{sessionUser} & \texttt{User} & Utente della sessione corrente \\
\bottomrule
\end{tabular}
\caption{Attributi di CreaOrdineFacade}
\end{table}

\subsubsection{Costruttore e Autorizzazione}

Il costruttore implementa un meccanismo di \textbf{autorizzazione basata su token}:

\begin{enumerate}
    \item Recupera l'utente dal \texttt{SessionManager} tramite il token
    \item Verifica che l'utente esista e abbia il ruolo \texttt{CLIENTE}
    \item Lancia \texttt{MissingAuthorizationException} se la verifica fallisce
    \item Inizializza il controller delegato
\end{enumerate}

Questo approccio implementa il principio di \textbf{Fail-Fast}: se l'autorizzazione fallisce, l'oggetto non viene nemmeno creato.

\subsection{Metodi del Facade}

\subsubsection{inizializzaNuovoOrdine()}

\begin{lstlisting}[caption={Metodo inizializzaNuovoOrdine}]
public OrdineBean inizializzaNuovoOrdine() throws DAOException {
    // Use actual client ID from session user
    String actualClienteId = sessionUser.getId();
    return controller.inizializzaNuovoOrdine(actualClienteId);
}
\end{lstlisting}

\textbf{Responsabilità:}
\begin{itemize}
    \item Estrae l'ID del cliente dalla sessione (non dallo strato presentation)
    \item Delega la creazione dell'ordine al controller
    \item Restituisce un \texttt{OrdineBean} (DTO) con i dati dell'ordine
\end{itemize}

\textbf{Applicazione GRASP:}
\begin{itemize}
    \item \textbf{Information Expert}: Il Facade ha accesso al \texttt{sessionUser} e quindi all'ID del cliente
    \item \textbf{Low Coupling}: Il controller non conosce la sessione, riceve solo l'ID
\end{itemize}

\subsubsection{getProdottiBaseDisponibili() e getAddOnDisponibili()}

\begin{lstlisting}[caption={Metodi per recuperare prodotti e add-on}]
public List<FoodBean> getProdottiBaseDisponibili() 
        throws DAOException, ObjectNotFoundException, ... {
    return controller.getProdottiBaseDisponibili();
}

public List<FoodBean> getAddOnDisponibili() 
        throws DAOException, ObjectNotFoundException, ... {
    return controller.getAddOnDisponibili();
}
\end{lstlisting}

\textbf{Responsabilità:}
\begin{itemize}
    \item Recuperano i dati dei prodotti/add-on disponibili dal sistema
    \item Restituiscono liste di \texttt{FoodBean} invece di oggetti \texttt{Food}
\end{itemize}

Questi metodi seguono il pattern \textbf{Pure Delegation}: il Facade non aggiunge logica, ma delega completamente al controller.

\subsubsection{aggiungiProdottoAOrdine()}

\begin{lstlisting}[caption={Metodo aggiungiProdottoAOrdine}]
public boolean aggiungiProdottoAOrdine(FoodBean foodBean) {
    return controller.aggiungiProdottoAOrdine(foodBean);
}
\end{lstlisting}

\textbf{Flusso interno (nel Controller):}
\begin{enumerate}
    \item Crea il prodotto base usando \texttt{FoodFactory}
    \item Applica i Decorator per ogni add-on selezionato
    \item Aggiunge il prodotto decorato all'ordine
\end{enumerate}

Il Facade nasconde completamente l'applicazione del \textbf{pattern Decorator} ai client esterni.

\subsubsection{applicaVoucher() e rimuoviVoucher()}

\begin{lstlisting}[caption={Metodi per gestire i voucher}]
public VoucherBean applicaVoucher(String codiceVoucher)
        throws DAOException, ObjectNotFoundException, ... {
    return controller.applicaVoucher(codiceVoucher);
}

public void rimuoviVoucher() {
    controller.rimuoviVoucher();
}
\end{lstlisting}

Il controller, a sua volta, delega a \texttt{UsaVoucherController} implementando il principio GRASP \textbf{Single Responsibility}: ogni controller ha una sola responsabilità.

\subsubsection{getRiepilogoOrdine()}

\begin{lstlisting}[caption={Metodo getRiepilogoOrdine}]
public RiepilogoOrdineBean getRiepilogoOrdine() {
    return controller.getRiepilogoOrdine();
}
\end{lstlisting}

Restituisce un \texttt{RiepilogoOrdineBean} contenente:
\begin{itemize}
    \item Lista delle righe ordine (prodotto + prezzo + durata)
    \item Subtotale, sconto e totale
    \item Informazioni sul voucher applicato
    \item Durata totale stimata
\end{itemize}

\subsubsection{confermaOrdine() e annullaOrdine()}

\begin{lstlisting}[caption={Metodi per conferma/annullamento}]
public boolean confermaOrdine() 
        throws DAOException, MissingAuthorizationException {
    return controller.confermaOrdine();
}

public void annullaOrdine() {
    controller.annullaOrdine();
}
\end{lstlisting}

\begin{itemize}
    \item \texttt{confermaOrdine()} persiste l'ordine nel database
    \item \texttt{annullaOrdine()} resetta lo stato del controller
\end{itemize}

\subsection{Diagramma di Sequenza: Creazione Ordine Completo}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    actor/.style={rectangle, draw, minimum height=0.8cm, minimum width=1.8cm, font=\scriptsize},
    arrow/.style={-{Stealth[length=2mm]}, thick},
    scale=0.9, transform shape
]

% Actors
\node[actor] (gui) at (0,0) {GUI};
\node[actor] (facade) at (2.5,0) {Facade};
\node[actor] (ctrl) at (5,0) {Controller};
\node[actor] (factory) at (7.5,0) {Factory};

% Lifelines
\draw[dashed] (0,-6.5) -- (gui.south);
\draw[dashed] (2.5,-6.5) -- (facade.south);
\draw[dashed] (5,-6.5) -- (ctrl.south);
\draw[dashed] (7.5,-6.5) -- (factory.south);

% Messages
\draw[arrow] (0,-0.8) -- node[above, font=\tiny] {new Facade(token)} (2.5,-0.8);
\draw[arrow] (0,-1.5) -- node[above, font=\tiny] {inizializzaNuovoOrdine()} (2.5,-1.5);
\draw[arrow] (2.5,-1.8) -- node[above, font=\tiny] {inizializzaNuovoOrdine(id)} (5,-1.8);
\draw[arrow] (5,-2.1) -- node[above, font=\tiny] {newOrdine(id)} (7.5,-2.1);
\draw[<-] (5,-2.5) -- (7.5,-2.5);

\draw[arrow] (0,-3.2) -- node[above, font=\tiny] {aggiungiProdotto(bean)} (2.5,-3.2);
\draw[arrow] (2.5,-3.5) -- node[above, font=\tiny] {aggiungiProdotto(bean)} (5,-3.5);
\draw[arrow] (5,-3.8) -- node[above, font=\tiny] {creaProdottoBase()} (7.5,-3.8);
\draw[arrow] (5,-4.2) -- node[above, font=\tiny] {applicaDecorator()} (7.5,-4.2);

\draw[arrow] (0,-5) -- node[above, font=\tiny] {confermaOrdine()} (2.5,-5);
\draw[arrow] (2.5,-5.3) -- node[above, font=\tiny] {confermaOrdine()} (5,-5.3);
\draw[arrow] (5,-5.6) -- node[above, font=\tiny] {salvaOrdine()} (7.5,-5.6);

\end{tikzpicture}
\caption{Sequenza semplificata della creazione ordine}
\end{figure}

% ==================== CREA ORDINE CONTROLLER ====================
\newpage
\section{CreaOrdineController --- Il Sottosistema}

\subsection{Descrizione Generale}

Il \texttt{CreaOrdineController} è il \textbf{Controller Applicativo} (BCE) per lo Use Case ``Crea Ordine''. Contiene la logica di business e coordina le interazioni tra le Entity.

\subsection{Struttura della Classe}

\begin{lstlisting}[caption={Dichiarazione CreaOrdineController}]
public class CreaOrdineController {

    private Ordine ordineCorrente;
    private final UsaVoucherController voucherController;

    public CreaOrdineController() {
        this.voucherController = new UsaVoucherController();
    }
}
\end{lstlisting}

\subsubsection{Responsabilità (GRASP Single Responsibility)}

\begin{enumerate}
    \item \textbf{Creazione ordini}: Inizializza e gestisce l'ordine corrente
    \item \textbf{Gestione prodotti}: Aggiunge/rimuove prodotti con pattern Decorator
    \item \textbf{Conversione Bean/Entity}: Trasforma i DTO in oggetti di dominio e viceversa
    \item \textbf{Persistenza}: Coordina il salvataggio tramite DAO
\end{enumerate}

\subsection{Metodo inizializzaNuovoOrdine()}

\begin{lstlisting}[caption={Inizializzazione nuovo ordine}]
public OrdineBean inizializzaNuovoOrdine(String clienteId) 
        throws DAOException {
    // Crea un nuovo ordine tramite la LazyFactory
    ordineCorrente = OrdineLazyFactory.getInstance()
        .newOrdine(clienteId);

    // Converti in Bean e restituisci
    return org.example.mappers.OrdineMapper.toBean(ordineCorrente);
}
\end{lstlisting}

\textbf{Pattern applicati:}
\begin{itemize}
    \item \textbf{Lazy Factory}: La creazione dell'ordine è delegata a \texttt{OrdineLazyFactory}
    \item \textbf{Mapper}: La conversione Entity→Bean è delegata a \texttt{OrdineMapper}
\end{itemize}

\subsection{Metodo aggiungiProdottoAOrdine()}

\begin{lstlisting}[caption={Aggiunta prodotto con Decorator}]
public boolean aggiungiProdottoAOrdine(FoodBean foodBean) {
    if (ordineCorrente == null || foodBean == null) {
        return false;
    }

    // Crea il prodotto base (GRASP: Low Coupling)
    Food prodotto = FoodFactory.creaProdottoBase(
        foodBean.getClasse());
    if (prodotto == null) {
        return false;
    }

    // Applica gli add-on usando pattern Decorator
    for (String addOnClasse : foodBean.getAddOnSelezionati()) {
        prodotto = FoodFactory.applicaDecorator(prodotto, addOnClasse);
    }

    // Aggiungi all'ordine
    ordineCorrente.aggiungiProdotto(prodotto);
    return true;
}
\end{lstlisting}

\textbf{Pattern Decorator:} Ogni add-on ``avvolge'' il prodotto base, aggiungendo funzionalità (costo, descrizione, durata) in modo trasparente.

\subsection{Metodo getRiepilogoOrdine()}

\begin{lstlisting}[caption={Generazione riepilogo ordine}]
public RiepilogoOrdineBean getRiepilogoOrdine() {
    if (ordineCorrente == null) {
        return null;
    }

    RiepilogoOrdineBean riepilogo = new RiepilogoOrdineBean();
    riepilogo.setNumeroOrdine(ordineCorrente.getNumeroOrdine());

    // Aggiungi le righe dei prodotti
    for (Food food : ordineCorrente.getProdotti()) {
        RigaOrdineBean riga = new RigaOrdineBean(
                food.getDescrizione(),
                food.getCosto(),
                food.getDurata());
        riepilogo.aggiungiRiga(riga);
    }

    // Calcola i totali
    riepilogo.setSubtotale(ordineCorrente.getSubtotale());
    riepilogo.setSconto(ordineCorrente.getSconto());
    riepilogo.setTotale(ordineCorrente.getTotale());
    riepilogo.setDurataTotale(ordineCorrente.getDurataTotale());

    // Info voucher
    if (voucherController.hasVoucherApplicato(ordineCorrente)) {
        Voucher v = ordineCorrente.getVoucher();
        riepilogo.setVoucherApplicato(true);
        riepilogo.setCodiceVoucher(v.getCodice());
        riepilogo.setDescrizioneVoucher(v.getDescrizione());
    }

    return riepilogo;
}
\end{lstlisting}

Questo metodo dimostra il principio \textbf{Information Expert}: il controller, che ha accesso all'ordine, è responsabile della creazione del riepilogo.

% ==================== CREA VOUCHER FACADE ====================
\newpage
\section{CreaVoucherFacade --- Analisi Dettagliata}

\subsection{Descrizione Generale}

Il \texttt{CreaVoucherFacade} gestisce lo Use Case ``Crea Voucher'', riservato esclusivamente al ruolo \textbf{AMMINISTRATORE}.

\subsection{Struttura della Classe}

\begin{lstlisting}[caption={Classe CreaVoucherFacade}]
/**
 * Facade per lo Use Case "Crea Voucher".
 * 
 * Fornisce un'interfaccia semplificata per la creazione
 * di voucher, gestendo autenticazione e autorizzazione.
 * 
 * Solo gli utenti con ruolo AMMINISTRATORE possono 
 * creare voucher.
 */
public class CreaVoucherFacade {

    private final CreaVoucherController controller;
    private final User sessionUser;

    public CreaVoucherFacade(String tokenKey) 
            throws MissingAuthorizationException {
        this.sessionUser = SessionManager.getInstance()
            .getSessionUserByTokenKey(tokenKey);

        if (sessionUser == null) {
            throw new MissingAuthorizationException(
                "Sessione non valida o scaduta");
        }

        // Verifica ruolo AMMINISTRATORE
        if (sessionUser.getRole() == null || 
            sessionUser.getRole().getAmministratoreRole() == null) {
            throw new MissingAuthorizationException(
                "Solo gli amministratori possono creare voucher");
        }

        this.controller = new CreaVoucherController();
    }
}
\end{lstlisting}

\subsection{Controllo Autorizzazioni}

Questo Facade implementa un \textbf{doppio livello di verifica}:

\begin{enumerate}
    \item \textbf{Autenticazione}: Verifica che il token corrisponda a un utente valido
    \item \textbf{Autorizzazione}: Verifica che l'utente abbia il ruolo \texttt{AMMINISTRATORE}
\end{enumerate}

\subsection{Metodo creaVoucher()}

\begin{lstlisting}[caption={Metodo creaVoucher del Facade}]
public Voucher creaVoucher(CreaVoucherBean bean)
        throws ValidationException, DAOException, 
               PropertyException, ResourceNotFoundException, 
               MissingAuthorizationException {
    return controller.creaVoucher(bean);
}
\end{lstlisting}

Il Facade delega completamente al controller, che esegue:
\begin{enumerate}
    \item Validazione sintattica (tramite \texttt{bean.validate()})
    \item Validazione semantica (unicità codice)
    \item Creazione dell'entity Voucher appropriata
    \item Persistenza tramite DAO
\end{enumerate}

% ==================== CREA VOUCHER CONTROLLER ====================
\section{CreaVoucherController --- Il Sottosistema}

\subsection{Responsabilità}

\begin{enumerate}
    \item Validazione regole di business
    \item Pattern \textbf{Creator} per la creazione dei voucher
    \item Coordinamento con il DAO per la persistenza
\end{enumerate}

\subsection{Metodo creaVoucher() del Controller}

\begin{lstlisting}[caption={Creazione voucher con validazione}]
public Voucher creaVoucher(CreaVoucherBean bean)
        throws ValidationException, DAOException, ... {

    // 1. Validazione sintattica
    bean.validate();

    // 2. Validazione semantica: unicita' codice
    verificaUnicitaCodice(bean.getCodice());

    // 3. Crea entity (GRASP: Creator pattern)
    Voucher voucher = creaVoucherEntity(bean);

    // 4. Persisti
    persistiVoucher(voucher);

    logger.info("Voucher creato: " + voucher.getCodice());
    return voucher;
}
\end{lstlisting}

\subsection{Creazione Polimorfica del Voucher}

\begin{lstlisting}[caption={Factory Method per tipi di voucher}]
private Voucher creaVoucherEntity(CreaVoucherBean bean) 
        throws ValidationException {
    String tipo = bean.getTipoVoucher();

    if ("PERCENTUALE".equals(tipo)) {
        return creaVoucherPercentuale(bean);
    } else if ("FISSO".equals(tipo)) {
        return creaVoucherFisso(bean);
    } else {
        throw new ValidationException(
            "Tipo voucher non riconosciuto: " + tipo);
    }
}

private VoucherPercentuale creaVoucherPercentuale(
        CreaVoucherBean bean) {
    VoucherPercentuale v = new VoucherPercentuale(
            bean.getCodice(),
            bean.getValore());
    if (bean.getDataScadenza() != null) {
        v.setDataScadenza(bean.getDataScadenza());
    }
    return v;
}

private VoucherFisso creaVoucherFisso(CreaVoucherBean bean) {
    VoucherFisso v = new VoucherFisso(
            bean.getCodice(),
            bean.getValore(),
            bean.getMinimoOrdine());
    if (bean.getDataScadenza() != null) {
        v.setDataScadenza(bean.getDataScadenza());
    }
    return v;
}
\end{lstlisting}

\textbf{Pattern applicati:}
\begin{itemize}
    \item \textbf{Factory Method}: La creazione è delegata a metodi specifici per tipo
    \item \textbf{Creator (GRASP)}: Il controller ha le informazioni necessarie per creare il voucher
\end{itemize}

% ==================== USA VOUCHER FACADE ====================
\newpage
\section{UsaVoucherFacade --- Analisi Dettagliata}

\subsection{Descrizione Generale}

Il \texttt{UsaVoucherFacade} gestisce l'applicazione di voucher agli ordini. Può essere usato:
\begin{itemize}
    \item Direttamente dal controller grafico
    \item Indirettamente tramite \texttt{CreaOrdineFacade}
\end{itemize}

\subsection{Struttura della Classe}

\begin{lstlisting}[caption={Classe UsaVoucherFacade}]
public class UsaVoucherFacade {

    private final UsaVoucherController controller;

    public UsaVoucherFacade() {
        this.controller = new UsaVoucherController();
    }
}
\end{lstlisting}

\textbf{Nota:} Questo Facade \textbf{non richiede autenticazione} nel costruttore. L'autorizzazione è implicita: solo chi ha accesso all'oggetto \texttt{Ordine} può applicare voucher.

\subsection{Metodi del Facade}

\begin{table}[H]
\centering
\begin{tabular}{@{}lp{8cm}@{}}
\toprule
\textbf{Metodo} & \textbf{Descrizione} \\
\midrule
\texttt{applicaVoucher()} & Applica un voucher all'ordine, restituisce \texttt{VoucherBean} \\
\texttt{rimuoviVoucher()} & Rimuove il voucher dall'ordine \\
\texttt{hasVoucherApplicato()} & Verifica se l'ordine ha un voucher \\
\texttt{getVoucherApplicato()} & Restituisce il \texttt{VoucherBean} del voucher applicato \\
\texttt{calcolaSconto()} & Calcola l'importo dello sconto \\
\texttt{getController()} & Espone il controller interno (per composizione) \\
\bottomrule
\end{tabular}
\caption{Metodi di UsaVoucherFacade}
\end{table}

\subsection{Metodo applicaVoucher()}

\begin{lstlisting}[caption={Applicazione voucher}]
public VoucherBean applicaVoucher(Ordine ordine, 
        String codiceVoucher) throws DAOException, 
        ObjectNotFoundException, ... {
    return controller.applicaVoucherAOrdine(ordine, codiceVoucher);
}
\end{lstlisting}

Il controller esegue:
\begin{enumerate}
    \item Cerca il voucher nel sistema tramite \texttt{VoucherLazyFactory}
    \item Verifica la validità del voucher (\texttt{isValido()})
    \item Applica il voucher all'ordine (\texttt{ordine.applicaVoucher()})
    \item Converte il risultato in \texttt{VoucherBean}
\end{enumerate}

% ==================== USA VOUCHER CONTROLLER ====================
\section{UsaVoucherController --- Il Sottosistema}

\subsection{Responsabilità}

Il \texttt{UsaVoucherController} è il \textbf{controller specializzato} per la gestione dei voucher:

\begin{enumerate}
    \item Recupero voucher dal sistema
    \item Validazione voucher
    \item Applicazione/rimozione da ordini
    \item Calcolo sconti
    \item Conversione Entity→Bean
\end{enumerate}

\subsection{Metodo applicaVoucherAOrdine()}

\begin{lstlisting}[caption={Applicazione voucher all'ordine}]
public VoucherBean applicaVoucherAOrdine(Ordine ordine, 
        String codiceVoucher) throws DAOException, ... {

    if (ordine == null || codiceVoucher == null || 
        codiceVoucher.trim().isEmpty()) {
        return null;
    }

    try {
        // Cerca il voucher
        Voucher voucher = getVoucherByCodice(codiceVoucher);

        // Verifica validita'
        if (!isVoucherValido(voucher)) {
            return null;
        }

        // Applica all'ordine
        ordine.applicaVoucher(voucher);

        // Converti in Bean
        return convertVoucherToBean(voucher);

    } catch (ObjectNotFoundException e) {
        return null;
    }
}
\end{lstlisting}

\subsection{Conversione Polimorfica in Bean}

\begin{lstlisting}[caption={Conversione Voucher in Bean}]
public VoucherBean convertVoucherToBean(Voucher voucher) {
    if (voucher == null) {
        return null;
    }

    VoucherBean bean = new VoucherBean();
    bean.setId(voucher.getId());
    bean.setCodice(voucher.getCodice());
    bean.setDescrizione(voucher.getDescrizione());
    bean.setTipoVoucher(voucher.getTipoVoucher());
    bean.setDataScadenza(voucher.getDataScadenza());
    bean.setValido(voucher.isValido());

    // Pattern Matching (Java 17)
    if (voucher instanceof VoucherPercentuale vp) {
        bean.setValore(vp.getPercentuale());
    } else if (voucher instanceof VoucherFisso vf) {
        bean.setValore(vf.getImportoSconto());
        bean.setMinimoOrdine(vf.getMinimoOrdine());
    }

    return bean;
}
\end{lstlisting}

% ==================== STORICO ORDINI FACADE ====================
\newpage
\section{StoricoOrdiniFacade --- Analisi Dettagliata}

\subsection{Descrizione Generale}

Il \texttt{StoricoOrdiniFacade} permette ai clienti di visualizzare i propri ordini passati.

\subsection{Struttura della Classe}

\begin{lstlisting}[caption={Classe StoricoOrdiniFacade}]
public class StoricoOrdiniFacade {

    private final StoricoOrdiniController controller = 
        new StoricoOrdiniController();

    public List<OrdineBean> getStoricoOrdini() 
            throws DAOException, ... {
        User user = SessionManager.getInstance().getSessionUser();
        if (user == null) {
            throw new MissingAuthorizationException(
                "Nessun utente loggato");
        }

        List<Ordine> ordini = controller.getOrdiniByCliente(user);
        List<OrdineBean> beans = new ArrayList<>();

        for (Ordine o : ordini) {
            OrdineBean bean = OrdineMapper.toBean(o);
            if (bean != null) {
                beans.add(bean);
            }
        }
        return beans;
    }
}
\end{lstlisting}

\subsection{Caratteristiche Distintive}

\begin{enumerate}
    \item \textbf{Nessun token nel costruttore}: Usa \texttt{getSessionUser()} invece di passare il token
    \item \textbf{Conversione in-place}: La trasformazione Entity→Bean avviene nel Facade stesso
    \item \textbf{Filtering null}: Ignora eventuali conversioni fallite
\end{enumerate}

% ==================== VISUALIZZA ORDINI FACADE ====================
\section{VisualizzaOrdiniFacade --- Analisi Dettagliata}

\subsection{Descrizione Generale}

Il \texttt{VisualizzaOrdiniFacade} è dedicato alla gestione degli ordini da parte dell'amministratore/kebabbaro.

\subsection{Struttura della Classe}

\begin{lstlisting}[caption={Classe VisualizzaOrdiniFacade}]
public class VisualizzaOrdiniFacade {

    private final VisualizzaOrdiniController controller = 
        new VisualizzaOrdiniController();

    public List<OrdineBean> getOrdiniInCreazione() 
            throws DAOException, ... {
        List<Ordine> ordini = controller
            .getOrdiniByStato(StatoOrdine.IN_CREAZIONE);
        List<OrdineBean> beans = new ArrayList<>();

        for (Ordine o : ordini) {
            OrdineBean bean = OrdineMapper.toBean(o);
            if (bean != null) {
                beans.add(bean);
            }
        }
        return beans;
    }

    public void impostaInConsegna(OrdineBean ordineBean) 
            throws DAOException, ... {
        controller.aggiornaStatoOrdine(
            ordineBean.getNumeroOrdine(), 
            StatoOrdine.IN_CONSEGNA);
    }
}
\end{lstlisting}

\subsection{Pattern State}

Il metodo \texttt{impostaInConsegna()} è parte dell'implementazione del \textbf{pattern State} per gli ordini. Lo stato dell'ordine può essere:
\begin{itemize}
    \item \texttt{IN\_CREAZIONE}
    \item \texttt{IN\_CONSEGNA}
    \item \texttt{CONSEGNATO}
    \item \texttt{ANNULLATO}
\end{itemize}

% ==================== PART III: ANALISI COMPARATIVA ====================
\newpage
\part{Analisi Comparativa e Conclusioni}

\section{Confronto tra i Facade}

\begin{table}[H]
\centering
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Facade} & \textbf{Token?} & \textbf{Ruolo} & \textbf{Metodi} & \textbf{Conversione} \\
\midrule
CreaOrdineFacade & Sì & Cliente & 10 & Delegata \\
CreaVoucherFacade & Sì & Admin & 1 & Delegata \\
UsaVoucherFacade & No & --- & 6 & Delegata \\
StoricoOrdiniFacade & Implicito & Cliente & 1 & In-place \\
VisualizzaOrdiniFacade & No & Admin & 2 & In-place \\
\bottomrule
\end{tabular}
\caption{Confronto caratteristiche dei Facade}
\end{table}

\section{Principi GRASP Applicati}

\begin{longtable}{@{}p{3.5cm}p{3cm}p{7cm}@{}}
\toprule
\textbf{Principio} & \textbf{Facade} & \textbf{Applicazione} \\
\midrule
\endhead

\textbf{Controller} & Tutti & I Facade fungono da controller per i loro Use Case \\
\addlinespace

\textbf{Low Coupling} & Tutti & I client dipendono solo dal Facade, non dal sottosistema \\
\addlinespace

\textbf{High Cohesion} & Tutti & Ogni Facade gestisce un solo Use Case \\
\addlinespace

\textbf{Information Expert} & CreaOrdineFacade & Ha accesso al sessionUser per l'ID cliente \\
\addlinespace

\textbf{Creator} & CreaVoucherCtrl & Ha le informazioni per creare i Voucher \\
\addlinespace

\textbf{Indirection} & Tutti & Aggiungono indirezione tra Boundary e Control \\
\addlinespace

\textbf{Protected Variations} & Tutti & Proteggono i client dalle variazioni interne \\
\addlinespace

\textbf{Pure Fabrication} & UsaVoucherFacade & Classe artificiale per gestire la responsabilità voucher \\
\bottomrule
\end{longtable}

\section{Pattern GoF Applicati}

\begin{enumerate}
    \item \textbf{Facade} (Strutturale): Interfaccia unificata per i sottosistemi
    \item \textbf{Singleton}: SessionManager per la gestione sessioni
    \item \textbf{Decorator}: In CreaOrdineController per gli add-on
    \item \textbf{Factory Method}: In CreaVoucherController per tipi di voucher
    \item \textbf{State}: In VisualizzaOrdiniController per gli stati ordine
\end{enumerate}

\section{Benefici dell'Architettura}

\begin{enumerate}
    \item \textbf{Testabilità}: Ogni Facade può essere testato in isolamento
    \item \textbf{Manutenibilità}: Le modifiche al sottosistema non impattano i client
    \item \textbf{Sicurezza}: L'autorizzazione è centralizzata nei costruttori
    \item \textbf{Riusabilità}: I controller possono essere riutilizzati da più Facade
    \item \textbf{Separation of Concerns}: Chiara separazione tra presentation, application e domain
\end{enumerate}

\section{Conclusioni}

L'implementazione del pattern Facade nel progetto Habibi Shawarma rappresenta un esempio efficace di applicazione dei pattern GoF e dei principi GRASP nell'architettura BCE. 

Ogni Facade:
\begin{itemize}
    \item Fornisce un'\textbf{interfaccia semplificata} per uno Use Case
    \item Gestisce l'\textbf{autenticazione/autorizzazione} quando necessario
    \item \textbf{Nasconde la complessità} del sottosistema (Controller, Entity, DAO)
    \item Promuove il \textbf{basso accoppiamento} tra i layer
\end{itemize}

Il design risultante è modulare, manutenibile e conforme ai principi dell'ingegneria del software.

\vspace{1cm}
\begin{center}
\rule{0.5\textwidth}{0.4pt}
\end{center}

\end{document}
